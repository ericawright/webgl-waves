diff --git a/app.js b/app.js
index 0381a0e..f3801ca 100644
--- a/app.js
+++ b/app.js
@@ -1,25 +1,36 @@
 "use strict"
 
+
+
 // Entrypoint
-function InitDemo() {
+function initDemo() {
   var canvas = document.getElementById("canvas");
   var gl = canvas.getContext("webgl");
   if (!gl) {
     return;
   }
-  var program = createProgramFromScripts(gl, ["2d-vertex-shader", "2d-fragment-shader"]);
-  var spinProgram = createProgramFromScripts(gl, ["2d-vertex-shader-spin", "2d-fragment-shader-spin"]);
+
+   // webglUtils.resizeCanvasToDisplaySize(gl.canvas);
+   console.log(canvas.width, canvas.height)
+
+  var program = webglUtils.createProgramFromScripts(gl, ["2d-vertex-shader", "2d-fragment-shader"]);
+  var blurProgram =  webglUtils.createProgramFromScripts(gl, ["2d-vertex-shader-blur", "2d-fragment-shader-blur"]);
+  var spinProgram =  webglUtils.createProgramFromScripts(gl, ["2d-vertex-shader-spin", "2d-fragment-shader-spin"]);
 
   // look up where the vertex data needs to go.
   var positionLocation = gl.getAttribLocation(program, "a_position");
   var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");
+  
+  var blurPositionLocation = gl.getAttribLocation(blurProgram, "a_position");
+  var blurTexCoordLocation = gl.getAttribLocation(blurProgram, "a_texCoord");
 
   // Create a buffer to put three 2d clip space points in
   var positionBuffer = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
   
   // Set a rectangle the same size as the canvas.
-  setRectangle(gl, 0, 0, canvas.clientWidth, canvas.clientHeight);
+  // setRectangle(gl, 0, 0, canvas.clientWidth, canvas.clientHeight);
+  setRectangle( gl, 0, 0, 10000, 2048);
 
   // provide texture coordinates for the rectangle.
   var texcoordBuffer = gl.createBuffer();
@@ -49,15 +60,14 @@ function InitDemo() {
   var offsetLocation = gl.getUniformLocation(program, "u_offset");
   var widthLocation = gl.getUniformLocation(program, "u_width");
   var timeLocation = gl.getUniformLocation(program, "u_time");
+  // Blur Uniforms
+  var textureSizeLocation = gl.getUniformLocation(blurProgram, "u_textureSize");
+  var kernelLocation = gl.getUniformLocation(blurProgram, "u_kernel[0]");
+  var kernelWeightLocation = gl.getUniformLocation(blurProgram, "u_kernelWeight");
+  var directionLocation =  gl.getUniformLocation(blurProgram, "dir");
+  var blurResolutionLocation = gl.getUniformLocation(blurProgram, "u_resolution");
+  var blurImageLocation = gl.getUniformLocation(blurProgram, "u_image");
 
-  resizeCanvasToDisplaySize(gl.canvas);
-
-  // Tell WebGL how to convert from clip space to pixels
-  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
-
-  // Clear the canvas
-  gl.clearColor(0, 0, 0, 0);
-  gl.clear(gl.COLOR_BUFFER_BIT);
 
   // Tell it to use our program (pair of shaders)
   gl.useProgram(program);
@@ -87,430 +97,400 @@ function InitDemo() {
       texcoordLocation, size, type, normalize, stride, offset);
 
   // set the resolution
-  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
-
-  var onImageLoad = function(event) {
-    
+  gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
+  
+  var createAndSetupTexture = function () {
     var texture = gl.createTexture();
     gl.bindTexture(gl.TEXTURE_2D, texture);
-
-    // Set the parameters so we can render any size image.
     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
+    return texture;
+  }
+  
 
-    // Upload the image into the texture.
-    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, event.target);
-
-    requestAnimationFrame(animate);
-  };
   var image = new Image();
-  image.src = "all-wavesa.png";
-  image.onload = onImageLoad;
-
-  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
-  gl.enable(gl.BLEND);
-  gl.disable(gl.DEPTH_TEST);
-
-  gl.uniform1i(imageLocation, 0);
-  gl.uniform1f(widthLocation, .123); // Width of each image
+  image.src = "./all-wavesa.png";
+  image.width = 10000;
+  image.height = 2048;
+  image.onload = function () {
+    var originalImageTexture = createAndSetupTexture();
+    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
     
-  function drawWaves(time, movement) {
-    gl.uniform1f(offsetLocation, movement.texture_offset);
-    gl.uniform1f(xScaleBaseLocation, movement.xScaleBase);
-    gl.uniform1f(yScaleBaseLocation, movement.yScaleBase);
-    gl.uniform1f(xScaleVarienceLocation, movement.xScaleVarience);
-    gl.uniform1f(yScaleVarienceLocation, movement.yScaleVarience);
-    gl.uniform1f(xSkewVarienceLocation, movement.xSkewVarience);
-    gl.uniform1f(ySkewVarienceLocation, movement.ySkewVarience);
-    gl.uniform1f(initialXLocation, movement.initialX);
-    gl.uniform1f(initialYLocation, movement.initialY);
-    gl.uniform1f(xTranslateLocation, movement.translateX);
-    gl.uniform1f(yTranslateLocation, movement.translateY);
-    gl.uniform1f(timeLocation, ((time * movement.speed) + movement.delay) % movement.period);
-    gl.drawArrays(gl.TRIANGLES, 0, 6);
-  }
-  
-  let wave1Movement = {
-    xScaleBase: 1.45,
-    yScaleBase: 1.5,
-    xScaleVarience: 0.1,
-    yScaleVarience: 0.1,
-    xSkewVarience: 0.0,
-    ySkewVarience: 0.0,
-    initialX: 0.0,
-    initialY: 0.1,
-    translateX: 0.0,
-    translateY: 0.0,
-    delay: 3.2,
-    speed: 0.0015,
-    texture_offset: 0.0,
-    period: 11,
+    var framebuffers = [];
+    var gb2pass = [
+        0.110536,
+        0.110967,
+        0.111275,
+        0.111461,
+        0.111523,
+        0.111461,
+        0.111275,
+        0.110967,
+        0.110536
+      ];
     
-    spin_delay: -1.0,
-    spin_radians: 4.0,
-    spin_translateX: 0.9,
-    spin_translateY: 1.4,
-    spin_speed: 0.002,
-  }
-  let wave2Movement = {
-    xScaleBase: 1.4,
-    yScaleBase: 1.3,
-    xScaleVarience: 0.1,
-    yScaleVarience: 0.1,
-    xSkewVarience: 0.0,
-    ySkewVarience: 0.0,
-    initialX: 0.0,
-    initialY: -0.3,
-    translateX: 0.0,
-    translateY: 0.0,
-    delay: 3.2,
-    speed: 0.0016,
-    texture_offset: 0.124,
-    period: 11,
+    var textures = [];
+    var framebuffers = [];
+    for (var ii = 0; ii < 2; ++ii) {
+      var texture = createAndSetupTexture(gl);
+      textures.push(texture);
+
+      // make the texture the same size as the image
+      gl.texImage2D(
+          gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0,
+          gl.RGBA, gl.UNSIGNED_BYTE, null);
+
+      // Create a framebuffer
+      var fbo = gl.createFramebuffer();
+      framebuffers.push(fbo);
+      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
+
+      // Attach a texture to it.
+      gl.framebufferTexture2D(
+          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
+    }
     
-    spin_delay: -1.0,
-    spin_radians: 0.0,
-    spin_translateX: 0.1,
-    spin_translateY: -0.8,
-    spin_speed: 0.0028,
-  }
-  let wave3Movement = {
-    xScaleBase: 1.3,
-    yScaleBase: 0.6,
-    xScaleVarience: 0.2,
-    yScaleVarience: 0.0,
-    xSkewVarience: 0.3,
-    ySkewVarience: 0.0,
-    initialX: 0.0,
-    initialY: -0.5,
-    translateX: 0.0,
-    translateY: 0.0,
-    delay: 3.2,
-    speed: 0.0011,
-    texture_offset: 0.2495,
-    period: 11,
+    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
+    gl.enable(gl.BLEND);
+    gl.disable(gl.DEPTH_TEST);
+
+    gl.uniform1i(imageLocation, 0);
+    gl.uniform1f(widthLocation, .123); // Width of each image
+      
+    function drawWaves(time, movement) {
+      gl.uniform1f(offsetLocation, movement.texture_offset);
+      gl.uniform1f(xScaleBaseLocation, movement.xScaleBase);
+      gl.uniform1f(yScaleBaseLocation, movement.yScaleBase);
+      gl.uniform1f(xScaleVarienceLocation, movement.xScaleVarience);
+      gl.uniform1f(yScaleVarienceLocation, movement.yScaleVarience);
+      gl.uniform1f(xSkewVarienceLocation, movement.xSkewVarience);
+      gl.uniform1f(ySkewVarienceLocation, movement.ySkewVarience);
+      gl.uniform1f(initialXLocation, movement.initialX);
+      gl.uniform1f(initialYLocation, movement.initialY);
+      gl.uniform1f(xTranslateLocation, movement.translateX);
+      gl.uniform1f(yTranslateLocation, movement.translateY);
+      gl.uniform1f(timeLocation, ((time * movement.speed) + movement.delay) % movement.period);
+      gl.drawArrays(gl.TRIANGLES, 0, 6);
+    }
     
-    spin_delay: -1.0,
-    spin_radians: 2.1,
-    spin_translateX: 0.25,
-    spin_translateY: 0.25,
-    spin_speed: 0.0027,
-  }
-  let wave4Movement = {
-    xScaleBase: 1.3,
-    yScaleBase: 1.2,
-    xScaleVarience: 0.0,
-    yScaleVarience: -0.1,
-    xSkewVarience: -0.1,
-    ySkewVarience: 0.0,
-    initialX: 0.0,
-    initialY: -0.8,
-    translateX: 0.0,
-    translateY: 0.0,
-    delay: 3.2,
-    speed: 0.00018,
-    texture_offset: 0.3735,
-    period: 11,
+    let wave1Movement = {
+      xScaleBase: 1.45,
+      yScaleBase: 1.5,
+      xScaleVarience: 0.1,
+      yScaleVarience: 0.1,
+      xSkewVarience: 0.0,
+      ySkewVarience: 0.0,
+      initialX: 0.0,
+      initialY: 0.1,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.0015,
+      texture_offset: 0.0,
+      period: 11,
+      
+      spin_delay: -1.0,
+      spin_radians: 4.0,
+      spin_translateX: 0.9,
+      spin_translateY: 1.4,
+      spin_speed: 0.002,
+    }
+    let wave2Movement = {
+      xScaleBase: 1.4,
+      yScaleBase: 1.3,
+      xScaleVarience: 0.1,
+      yScaleVarience: 0.1,
+      xSkewVarience: 0.0,
+      ySkewVarience: 0.0,
+      initialX: 0.0,
+      initialY: -0.3,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.0016,
+      texture_offset: 0.124,
+      period: 11,
+      
+      spin_delay: -1.0,
+      spin_radians: 0.0,
+      spin_translateX: 0.1,
+      spin_translateY: -0.8,
+      spin_speed: 0.0028,
+    }
+    let wave3Movement = {
+      xScaleBase: 1.3,
+      yScaleBase: 0.6,
+      xScaleVarience: 0.2,
+      yScaleVarience: 0.0,
+      xSkewVarience: 0.3,
+      ySkewVarience: 0.0,
+      initialX: 0.0,
+      initialY: -0.5,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.0011,
+      texture_offset: 0.2495,
+      period: 11,
+      
+      spin_delay: -1.0,
+      spin_radians: 2.1,
+      spin_translateX: 0.25,
+      spin_translateY: 0.25,
+      spin_speed: 0.0027,
+    }
+    let wave4Movement = {
+      xScaleBase: 1.3,
+      yScaleBase: 1.2,
+      xScaleVarience: 0.0,
+      yScaleVarience: -0.1,
+      xSkewVarience: -0.1,
+      ySkewVarience: 0.0,
+      initialX: 0.0,
+      initialY: -0.8,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.00018,
+      texture_offset: 0.3735,
+      period: 11,
+      
+      spin_delay: -1.0,
+      spin_radians: 0.5,
+      spin_translateX: 0.4,
+      spin_translateY: -0.3,
+      spin_speed: 0.0026,
+    }
     
-    spin_delay: -1.0,
-    spin_radians: 0.5,
-    spin_translateX: 0.4,
-    spin_translateY: -0.3,
-    spin_speed: 0.0026,
-  }
-  
-  let wave5Movement = {
-    xScaleBase: 1.7,
-    yScaleBase: 0.5,
-    xScaleVarience: -0.2,
-    yScaleVarience: 0.1,
-    xSkewVarience: 0.3,
-    ySkewVarience: 0.0,
-    initialX: 0.15,
-    initialY: 0.15,
-    translateX: 0.0,
-    translateY: -0.1,
-    delay: 3.2,
-    speed: 0.0005,
-    texture_offset: 0.4965,
-    period: (4 * Math.PI),
+    let wave5Movement = {
+      xScaleBase: 1.7,
+      yScaleBase: 0.5,
+      xScaleVarience: -0.2,
+      yScaleVarience: 0.1,
+      xSkewVarience: 0.3,
+      ySkewVarience: 0.0,
+      initialX: 0.15,
+      initialY: 0.15,
+      translateX: 0.0,
+      translateY: -0.1,
+      delay: 3.2,
+      speed: 0.0005,
+      texture_offset: 0.4965,
+      period: (4 * Math.PI),
+      
+      spin_delay: -1.0,
+      spin_radians: 1.4,
+      spin_translateX: 0.8,
+      spin_translateY: -0.3,
+      spin_speed: 0.0025,
+    }
     
-    spin_delay: -1.0,
-    spin_radians: 1.4,
-    spin_translateX: 0.8,
-    spin_translateY: -0.3,
-    spin_speed: 0.0025,
-  }
-  
-  let wave6Movement = {
-    xScaleBase: 1.5,
-    yScaleBase: 1.3,
-    xScaleVarience: 0.15,
-    yScaleVarience: 0.15,
-    xSkewVarience: 0.2,
-    ySkewVarience: 0.0,
-    initialX: 0.0,
-    initialY: 0.4,
-    translateX: 0.0,
-    translateY: 0.0,
-    delay: 3.2,
-    speed: 0.00048,
-    texture_offset: 0.6215,
-    period: (4 * Math.PI),
+    let wave6Movement = {
+      xScaleBase: 1.5,
+      yScaleBase: 1.3,
+      xScaleVarience: 0.15,
+      yScaleVarience: 0.15,
+      xSkewVarience: 0.2,
+      ySkewVarience: 0.0,
+      initialX: 0.0,
+      initialY: 0.4,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.00048,
+      texture_offset: 0.6215,
+      period: (4 * Math.PI),
+      
+      spin_delay: -1.0,
+      spin_radians: 2.0,
+      spin_translateX: -0.6,
+      spin_translateY: -0.0,
+      spin_speed: 0.0026,
+    }
     
-    spin_delay: -1.0,
-    spin_radians: 2.0,
-    spin_translateX: -0.6,
-    spin_translateY: -0.0,
-    spin_speed: 0.0026,
-  }
-  
-  let wave7Movement = {
-    xScaleBase: 0.8,
-    yScaleBase: 1.0,
-    xScaleVarience: 0.1,
-    yScaleVarience: 0.25,
-    xSkewVarience: 0.15,
-    ySkewVarience: 0.0,
-    initialX: 0.3,
-    initialY: 0.4,
-    translateX: 0.0,
-    translateY: 0.0,
-    delay: 3.2,
-    speed: 0.0006,
-    texture_offset: 0.747,
-    period: (4 * Math.PI),
+    let wave7Movement = {
+      xScaleBase: 0.8,
+      yScaleBase: 1.0,
+      xScaleVarience: 0.1,
+      yScaleVarience: 0.25,
+      xSkewVarience: 0.15,
+      ySkewVarience: 0.0,
+      initialX: 0.3,
+      initialY: 0.4,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.0006,
+      texture_offset: 0.747,
+      period: (4 * Math.PI),
+      
+      spin_delay: -1.0,
+      spin_radians: 3.0,
+      spin_translateX: -0.4,
+      spin_translateY: -0.2,
+      spin_speed: 0.0025,
+    }
     
-    spin_delay: -1.0,
-    spin_radians: 3.0,
-    spin_translateX: -0.4,
-    spin_translateY: -0.2,
-    spin_speed: 0.0025,
-  }
-  
-  let wave8Movement = {
-    xScaleBase: 1.5,
-    yScaleBase: 0.8,
-    xScaleVarience: 0.0,
-    yScaleVarience: -0.05,
-    xSkewVarience: 0.2,
-    ySkewVarience: 0.0,
-    initialX: -0.11,
-    initialY: 0.3,
-    translateX: 0.0,
-    translateY: 0.0,
-    delay: 3.2,
-    speed: 0.00051,
-    texture_offset: 0.877,
-    period: (4 * Math.PI),
+    let wave8Movement = {
+      xScaleBase: 1.5,
+      yScaleBase: 0.8,
+      xScaleVarience: 0.0,
+      yScaleVarience: -0.05,
+      xSkewVarience: 0.2,
+      ySkewVarience: 0.0,
+      initialX: -0.11,
+      initialY: 0.3,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.00051,
+      texture_offset: 0.877,
+      period: (4 * Math.PI),
+      
+      spin_delay: -1.0,
+      spin_radians: 2.0,
+      spin_translateX: -0.4,
+      spin_translateY: -0.1,
+      spin_speed: 0.002,
+    }
     
-    spin_delay: -1.0,
-    spin_radians: 2.0,
-    spin_translateX: -0.4,
-    spin_translateY: -0.1,
-    spin_speed: 0.002,
-  }
-  
-  var myReq;
-  var oldTime = 0;
-  var waveStartTime = performance.now();
-  var waveDeltaTime = 0;
-
-  function animate(time) {
-    resizeCanvasToDisplaySize(gl.canvas);
-    waveDeltaTime = time - waveStartTime;
-    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
-    drawWaves(waveDeltaTime, wave1Movement);
-    drawWaves(waveDeltaTime, wave2Movement);
-    drawWaves(waveDeltaTime, wave3Movement);
-    drawWaves(waveDeltaTime, wave4Movement);
-    drawWaves(waveDeltaTime, wave5Movement);
-    drawWaves(waveDeltaTime, wave6Movement);
-    drawWaves(waveDeltaTime, wave7Movement);
-    drawWaves(waveDeltaTime, wave8Movement);
-  
-    myReq = window.requestAnimationFrame(animate);
-  }
-  
-  // Change to rotation/spin shaders on keypress
-  function handleKeyUp () {
-    gl.useProgram(spinProgram);
-
-    var spinResolutionLocation = gl.getUniformLocation(spinProgram, "u_resolution");
-    var spinTimeLocation = gl.getUniformLocation(spinProgram, "u_time");
-    var spinDegreesLocation = gl.getUniformLocation(spinProgram, "u_degrees");
-    var spinXTranslateLocation = gl.getUniformLocation(spinProgram, "u_x_spin_translate");
-    var spinYTranslateLocation = gl.getUniformLocation(spinProgram, "u_y_spin_translate");
-    var spinFragTimeLocation = gl.getUniformLocation(spinProgram, "u_spin_time");
-    var endTimeLocation = gl.getUniformLocation(spinProgram, "u_old_end_time");
-   
-    var spinWidthLocation = gl.getUniformLocation(spinProgram, "u_width");
-    var spinOffsetLocation = gl.getUniformLocation(spinProgram, "u_offset");
-    var spinResolutionLocation = gl.getUniformLocation(spinProgram, "u_resolution");
-    var spinInitialXLocation = gl.getUniformLocation(spinProgram, "u_x_coord");
-    var spinInitialYLocation = gl.getUniformLocation(spinProgram, "u_y_coord");
-    var spinXScaleBaseLocation = gl.getUniformLocation(spinProgram, "u_x_scale_base");
-    var spinYScaleBaseLocation = gl.getUniformLocation(spinProgram, "u_y_scale_base");
-    var spinXScaleVarienceLocation = gl.getUniformLocation(spinProgram, "u_x_scale_varience");
-    var spinYScaleVarienceLocation = gl.getUniformLocation(spinProgram, "u_y_scale_varience");
-    var spinXSkewVarienceLocation = gl.getUniformLocation(spinProgram, "u_x_skew_varience");
-    var spinYSkewVarienceLocation = gl.getUniformLocation(spinProgram, "u_y_skew_varience");
-    var spinOldXTranslateLocation = gl.getUniformLocation(spinProgram, "u_x_translate");
-    var spinOldYTranslateLocation = gl.getUniformLocation(spinProgram, "u_y_translate");
-    var spinImageLocation = gl.getUniformLocation(spinProgram, "u_image");
+    var myReq;
+    var oldTime = 0;
+    var waveStartTime = performance.now();
+    var waveDeltaTime = 0;
     
-    gl.uniform2f(spinResolutionLocation, gl.canvas.width, gl.canvas.height);
-    gl.uniform1i(spinImageLocation, 0);
-    gl.uniform1f(spinWidthLocation, .123);
-
-    function drawWaveSpin (time, movement) {
-      // old wave uniforms
-      gl.uniform1f(spinOffsetLocation, movement.texture_offset);
-      gl.uniform1f(spinXScaleBaseLocation, movement.xScaleBase);
-      gl.uniform1f(spinYScaleBaseLocation, movement.yScaleBase);
-      gl.uniform1f(spinXScaleVarienceLocation, movement.xScaleVarience);
-      gl.uniform1f(spinYScaleVarienceLocation, movement.yScaleVarience);
-      gl.uniform1f(spinXSkewVarienceLocation, movement.xSkewVarience);
-      gl.uniform1f(spinYSkewVarienceLocation, movement.ySkewVarience);
-      gl.uniform1f(spinInitialXLocation, movement.initialX);
-      gl.uniform1f(spinInitialYLocation, movement.initialY);
-      gl.uniform1f(spinOldXTranslateLocation, movement.translateX);
-      gl.uniform1f(spinOldYTranslateLocation, movement.translateY);
-      
-      // spin uniforms
-      gl.uniform1f(spinXTranslateLocation, movement.spin_translateX);
-      gl.uniform1f(spinYTranslateLocation, movement.spin_translateY);
-      gl.uniform1f(spinDegreesLocation, movement.spin_radians);
-      gl.uniform1f(endTimeLocation, ((waveDeltaTime * movement.speed) + movement.delay) % movement.period);
+    let nextTexture;
+    
+    gl.useProgram(blurProgram);
+
+    gl.uniform2f(textureSizeLocation, image.width, image.height);
+    gl.uniform1i(blurImageLocation, 0);
+    gl.uniform1fv(kernelLocation, gb2pass);
+    gl.uniform1f(kernelWeightLocation, 1.0);
+    nextTexture = nextTexture || originalImageTexture; 
+    for (let v = 0; v < 0; v++) {
+      // Use first frame buffer
+      gl.bindTexture(gl.TEXTURE_2D, nextTexture);
+      gl.uniform2f(directionLocation, 1.0, 0.0);
+      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[0]);
+      gl.uniform2f(blurResolutionLocation, canvas.width, canvas.height);
+      gl.drawArrays(gl.TRIANGLES, 0, 6);
+      nextTexture = textures[0];
       
-      gl.uniform1f(spinTimeLocation, (time * movement.spin_speed) + movement.spin_delay);
-      gl.uniform1f(spinFragTimeLocation, (time * movement.spin_speed) + -1.0);
+      // Use second framebuffer 
+      gl.bindTexture(gl.TEXTURE_2D, nextTexture);
+      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[1]);
+      gl.uniform2f(blurResolutionLocation, canvas.width, canvas.height);
+      gl.uniform2f(directionLocation, 0.0, 1.0);
       gl.drawArrays(gl.TRIANGLES, 0, 6);
+      nextTexture = textures[1];
     }
 
-    var deltaTime = 0;
-    var startTime = performance.now();
-    function spinOutAnimation(time) {
-      deltaTime = time-startTime;
-      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
-      drawWaveSpin(deltaTime, wave1Movement);
-      drawWaveSpin(deltaTime, wave2Movement);
-      drawWaveSpin(deltaTime, wave3Movement);
-      drawWaveSpin(deltaTime, wave4Movement);
-      drawWaveSpin(deltaTime, wave5Movement);
-      drawWaveSpin(deltaTime, wave6Movement);
-      drawWaveSpin(deltaTime, wave7Movement);
-      drawWaveSpin(deltaTime, wave8Movement);
-      window.requestAnimationFrame(spinOutAnimation);
+
+    
+    // Draw for real
+    gl.useProgram(program);
+    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+    // gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
+    gl.bindTexture(gl.TEXTURE_2D, nextTexture);    
+    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+    
+    function animate(time) {
+        waveDeltaTime = time - waveStartTime;
+      drawWaves(waveDeltaTime, wave1Movement);
+      drawWaves(waveDeltaTime, wave2Movement);
+      drawWaves(waveDeltaTime, wave3Movement);
+      drawWaves(waveDeltaTime, wave4Movement);
+      drawWaves(waveDeltaTime, wave5Movement);
+      drawWaves(waveDeltaTime, wave6Movement);
+      drawWaves(waveDeltaTime, wave7Movement);
+      drawWaves(waveDeltaTime, wave8Movement);
+    
+      myReq = window.requestAnimationFrame(animate);
     }
+    requestAnimationFrame(animate);
     
-    cancelAnimationFrame(myReq);
-    spinOutAnimation(startTime);
-  }
-  document.onkeyup = handleKeyUp;
-}
-
-
-
-// Utility Functions
-function resizeCanvasToDisplaySize(canvas, multiplier) {
-  multiplier = multiplier || 1;
-  var width  = canvas.clientWidth  * multiplier | 0;
-  var height = canvas.clientHeight * multiplier | 0;
-  if (canvas.width !== width ||  canvas.height !== height) {
-    canvas.width  = width;
-    canvas.height = height;
-    return true;
+    // Change to rotation/spin shaders on keypress
+    // function handleKeyUp () {
+    //   gl.useProgram(spinProgram);
+    // 
+    //   var spinResolutionLocation = gl.getUniformLocation(spinProgram, "u_resolution");
+    //   var spinTimeLocation = gl.getUniformLocation(spinProgram, "u_time");
+    //   var spinDegreesLocation = gl.getUniformLocation(spinProgram, "u_degrees");
+    //   var spinXTranslateLocation = gl.getUniformLocation(spinProgram, "u_x_spin_translate");
+    //   var spinYTranslateLocation = gl.getUniformLocation(spinProgram, "u_y_spin_translate");
+    //   var spinFragTimeLocation = gl.getUniformLocation(spinProgram, "u_spin_time");
+    //   var endTimeLocation = gl.getUniformLocation(spinProgram, "u_old_end_time");
+    // 
+    //   var spinWidthLocation = gl.getUniformLocation(spinProgram, "u_width");
+    //   var spinOffsetLocation = gl.getUniformLocation(spinProgram, "u_offset");
+    //   var spinResolutionLocation = gl.getUniformLocation(spinProgram, "u_resolution");
+    //   var spinInitialXLocation = gl.getUniformLocation(spinProgram, "u_x_coord");
+    //   var spinInitialYLocation = gl.getUniformLocation(spinProgram, "u_y_coord");
+    //   var spinXScaleBaseLocation = gl.getUniformLocation(spinProgram, "u_x_scale_base");
+    //   var spinYScaleBaseLocation = gl.getUniformLocation(spinProgram, "u_y_scale_base");
+    //   var spinXScaleVarienceLocation = gl.getUniformLocation(spinProgram, "u_x_scale_varience");
+    //   var spinYScaleVarienceLocation = gl.getUniformLocation(spinProgram, "u_y_scale_varience");
+    //   var spinXSkewVarienceLocation = gl.getUniformLocation(spinProgram, "u_x_skew_varience");
+    //   var spinYSkewVarienceLocation = gl.getUniformLocation(spinProgram, "u_y_skew_varience");
+    //   var spinOldXTranslateLocation = gl.getUniformLocation(spinProgram, "u_x_translate");
+    //   var spinOldYTranslateLocation = gl.getUniformLocation(spinProgram, "u_y_translate");
+    //   var spinImageLocation = gl.getUniformLocation(spinProgram, "u_image");
+    // 
+    //   gl.uniform2f(spinResolutionLocation, gl.canvas.width, gl.canvas.height);
+    //   gl.uniform1i(spinImageLocation, 0);
+    //   gl.uniform1f(spinWidthLocation, .123);
+    // 
+    //   function drawWaveSpin (time, movement) {
+    //     // old wave uniforms
+    //     gl.uniform1f(spinOffsetLocation, movement.texture_offset);
+    //     gl.uniform1f(spinXScaleBaseLocation, movement.xScaleBase);
+    //     gl.uniform1f(spinYScaleBaseLocation, movement.yScaleBase);
+    //     gl.uniform1f(spinXScaleVarienceLocation, movement.xScaleVarience);
+    //     gl.uniform1f(spinYScaleVarienceLocation, movement.yScaleVarience);
+    //     gl.uniform1f(spinXSkewVarienceLocation, movement.xSkewVarience);
+    //     gl.uniform1f(spinYSkewVarienceLocation, movement.ySkewVarience);
+    //     gl.uniform1f(spinInitialXLocation, movement.initialX);
+    //     gl.uniform1f(spinInitialYLocation, movement.initialY);
+    //     gl.uniform1f(spinOldXTranslateLocation, movement.translateX);
+    //     gl.uniform1f(spinOldYTranslateLocation, movement.translateY);
+    // 
+    //     // spin uniforms
+    //     gl.uniform1f(spinXTranslateLocation, movement.spin_translateX);
+    //     gl.uniform1f(spinYTranslateLocation, movement.spin_translateY);
+    //     gl.uniform1f(spinDegreesLocation, movement.spin_radians);
+    //     gl.uniform1f(endTimeLocation, ((waveDeltaTime * movement.speed) + movement.delay) % movement.period);
+    // 
+    //     gl.uniform1f(spinTimeLocation, (time * movement.spin_speed) + movement.spin_delay);
+    //     gl.uniform1f(spinFragTimeLocation, (time * movement.spin_speed) + -1.0);
+    //     gl.drawArrays(gl.TRIANGLES, 0, 6);
+    //   }
+    // 
+    //   var deltaTime = 0;
+    //   var startTime = performance.now();
+    //   function spinOutAnimation(time) {
+    //     deltaTime = time-startTime;
+    //     gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+    //     drawWaveSpin(deltaTime, wave1Movement);
+    //     drawWaveSpin(deltaTime, wave2Movement);
+    //     drawWaveSpin(deltaTime, wave3Movement);
+    //     drawWaveSpin(deltaTime, wave4Movement);
+    //     drawWaveSpin(deltaTime, wave5Movement);
+    //     drawWaveSpin(deltaTime, wave6Movement);
+    //     drawWaveSpin(deltaTime, wave7Movement);
+    //     drawWaveSpin(deltaTime, wave8Movement);
+    //     window.requestAnimationFrame(spinOutAnimation);
+    //   }
+    // 
+    //   cancelAnimationFrame(myReq);
+    //   spinOutAnimation(startTime);
+    // }
+    // document.onkeyup = handleKeyUp;
   }
-  return false;
 }
 
-function createProgram(gl, vertexShader, fragmentShader) {
-  // create a program.
-  var program = gl.createProgram();
-
-  // attach the shaders.
-  gl.attachShader(program, vertexShader);
-  gl.attachShader(program, fragmentShader);
-
-  // link the program.
-  gl.linkProgram(program);
-
-  // Check if it linked.
-  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
-  if (!success) {
-      // something went wrong with the link
-      throw ("program failed to link:" + gl.getProgramInfoLog (program));
-  }
-
-  return program;
-};
-
-function compileShader(gl, shaderSource, shaderType) {
-  // Create the shader object
-  var shader = gl.createShader(shaderType);
-
-  // Set the shader source code.
-  gl.shaderSource(shader, shaderSource);
-
-  // Compile the shader
-  gl.compileShader(shader);
-
-  // Check if it compiled
-  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
-  if (!success) {
-    // Something went wrong during compilation; get the error
-    throw "could not compile shader:" + gl.getShaderInfoLog(shader);
-  }
-
-  return shader;
-}
-
-function createShaderFromScript(gl, scriptId, opt_shaderType) {
-  // look up the script tag by id.
-  var shaderScript = document.getElementById(scriptId);
-  if (!shaderScript) {
-    throw("*** Error: unknown script element" + scriptId);
-  }
-
-  // extract the contents of the script tag.
-  var shaderSource = shaderScript.text;
-
-  // If we didn't pass in a type, use the 'type' from
-  // the script tag.
-  if (!opt_shaderType) {
-    if (shaderScript.type == "x-shader/x-vertex") {
-      opt_shaderType = gl.VERTEX_SHADER;
-    } else if (shaderScript.type == "x-shader/x-fragment") {
-      opt_shaderType = gl.FRAGMENT_SHADER;
-    } else if (!opt_shaderType) {
-      throw("*** Error: shader type not set");
-    }
-  }
-
-  return compileShader(gl, shaderSource, opt_shaderType);
-};
-
-function createProgramFromScripts(
-    gl, shaderScriptIds) {
-  var vertexShader = createShaderFromScript(gl, shaderScriptIds[0], gl.VERTEX_SHADER);
-  gl.compileShader(vertexShader);
-  if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
-    console.error('error compiling vertex shader', gl.getShaderInfoLog(vertexShader));
-    return;
-  }
-
-  var fragmentShader = createShaderFromScript(gl, shaderScriptIds[1], gl.FRAGMENT_SHADER);
-  gl.compileShader(fragmentShader);
-  if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
-    console.error('error compiling frag shader', gl.getShaderInfoLog(fragmentShader));
-    return;
-  }
-
-  return createProgram(gl, vertexShader, fragmentShader);
-}
 
 function setRectangle(gl, x, y, width, height) {
   var x1 = x;
diff --git a/index.html b/index.html
index 9f5d7dd..4fa9737 100644
--- a/index.html
+++ b/index.html
@@ -6,12 +6,72 @@
   <title>webgl test</title>
   <link rel="stylesheet" href="styles.css">
 </head>
-<body onload="InitDemo();">
-  <canvas id="canvas">
+<body onload="initDemo();">
+  <canvas id="canvas" width="10000" height="2048">
     HTML5 is not supported.
   </canvas>
   
-  <!-- vertex shader -->
+  <script id="2d-vertex-shader-blur" type="x-shader/x-vertex">
+  precision lowp float;
+
+  attribute vec2 a_position;
+  attribute vec2 a_texCoord;
+  
+  uniform vec2 u_resolution;
+  
+  varying vec2 v_texCoord;
+
+  void main() {
+    vec2 zeroToOne = a_position / u_resolution;
+    vec2 zeroToTwo = zeroToOne * 2.0;
+    vec2 clipSpace = zeroToTwo - 1.0;
+    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
+    // gl_Position = a_position;
+
+    v_texCoord = a_texCoord;
+  }
+
+  </script>
+
+  <script id="2d-fragment-shader-blur" type="x-shader/x-fragment">
+
+    precision lowp float;
+    
+    uniform sampler2D u_image;
+    uniform vec2 dir;
+    uniform vec2 u_textureSize;
+    uniform float u_kernel[9];
+    uniform float u_kernelWeight;
+
+    // the texCoords passed in from the vertex shader.
+    varying vec2 v_texCoord;
+
+    void main() {
+      float hstep = dir.x;
+      float vstep = dir.y;
+      vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
+      
+      // Blur
+      vec4 color =   
+         texture2D(u_image, v_texCoord + onePixel * vec2(-4.0*hstep, -4.0*vstep)) * u_kernel[0] +
+         texture2D(u_image, v_texCoord + onePixel * vec2(-3.0*hstep, -3.0*vstep)) * u_kernel[1] +
+         texture2D(u_image, v_texCoord + onePixel * vec2(-2.0*hstep, -2.0*vstep)) * u_kernel[2] +
+         texture2D(u_image, v_texCoord + onePixel * vec2(-1.0*hstep, -1.0*vstep)) * u_kernel[3] +
+         texture2D(u_image, v_texCoord + onePixel * vec2( 0.0,  0.0)) * u_kernel[4] +
+         texture2D(u_image, v_texCoord + onePixel * vec2( 1.0*hstep,  1.0*vstep)) * u_kernel[5] +
+         texture2D(u_image, v_texCoord + onePixel * vec2( 2.0*hstep,  2.0*vstep)) * u_kernel[6] +
+         texture2D(u_image, v_texCoord + onePixel * vec2( 3.0*hstep,  3.0*vstep)) * u_kernel[7] + 
+         texture2D(u_image, v_texCoord + onePixel * vec2( 4.0*hstep,  4.0*vstep)) * u_kernel[8];
+      
+      color = color/u_kernelWeight;
+      color = vec4(texture2D(u_image, v_texCoord).rgb, color.a);
+      // color.a = step(0.01, color.r + color.g + color.b);
+      
+      gl_FragColor = color;
+    }
+  </script>
+  
+  
   <script id="2d-vertex-shader-spin" type="x-shader/x-vertex">
   precision lowp float;
   const float PI = 3.14159;
@@ -76,7 +136,7 @@
     zeroToOne -= vec2(u_x_translate * (sin(oldTime) + 1.0), u_y_translate * (sin(oldTime) + 1.0));
     // End what was done by old shader
   
-    
+
     float time = max(u_time, 0.0); // allow delay if passed in - replace 0.0 with variable
     time = min(time, u_degrees); // count up by time to a certain degree, don't go past that degree
     zeroToOne = rotate(-time) * zeroToOne; // -time to always rotate clockwise
@@ -85,10 +145,8 @@
     translateTime = max(translateTime, 0.0); // delay at first - currently 0.0
     zeroToOne -= vec2(u_x_spin_translate * translateTime, u_y_spin_translate * translateTime);
     
-    
     zeroToOne += vec2(0.5); //return back to desired position
 
-
     vec2 zeroToTwo = zeroToOne * 2.0;
     vec2 clipSpace = zeroToTwo - 1.0;
     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
@@ -105,8 +163,8 @@
   attribute vec2 a_position;
   attribute vec2 a_texCoord;
 
-  uniform vec2 u_resolution;
   uniform float u_time;
+  uniform vec2 u_resolution;
   uniform float u_x_coord;
   uniform float u_y_coord;
   uniform float u_y_scale_base;
@@ -117,6 +175,7 @@
   uniform float u_x_skew_varience;
   uniform float u_y_translate;
   uniform float u_x_translate;
+  uniform float u_offset;
   
   varying vec2 v_texCoord;
   
@@ -141,21 +200,21 @@
     float y_scale = u_y_scale_base + u_y_scale_varience * (sin(time) + 1.0);
     float x_scale = u_x_scale_base + u_x_scale_varience * (sin(time) + 1.0);
     zeroToOne = scale(vec2(x_scale, y_scale)) * zeroToOne;
-
+    
     float x_skew = u_x_skew_varience * (sin(time) + 1.0);
     float y_skew = u_y_skew_varience * (sin(time) + 1.0);
     zeroToOne = zeroToOne * skew(vec2(x_skew, y_skew));
     
     zeroToOne -= vec2(u_x_coord, u_y_coord); //initial positioning
     zeroToOne -= vec2(u_x_translate * (sin(time) + 1.0), u_y_translate * (sin(time) + 1.0));
-
+    
     zeroToOne += vec2(0.5); //return back to desired position
 
     // convert from 0->1 to 0->2
     vec2 zeroToTwo = zeroToOne * 2.0;
     // convert from 0->2 to -1->+1 (clipspace)
     vec2 clipSpace = zeroToTwo - 1.0;
-    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
+    gl_Position = vec4(clipSpace * vec2(1, -1), 1.0 - u_offset, 1);
     // pass the texCoord to the fragment shader
     // The GPU will interpolate this value between points.
     v_texCoord = a_texCoord;
@@ -170,45 +229,28 @@
     uniform sampler2D u_image;
     uniform float u_width;
     uniform float u_offset;
-    // uniform vec2 dir;
-    // uniform vec2 u_textureSize;
-    // uniform float u_kernel[9];
-    // uniform float u_kernelWeight;
 
     // the texCoords passed in from the vertex shader.
     varying vec2 v_texCoord;
 
     void main() {
-      // float hstep = dir.x;
-      // float vstep = dir.y;
-      // vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
       vec2 texture_point = v_texCoord;
       texture_point.x *= u_width;
       texture_point.x += u_offset;
       vec4 color = texture2D(u_image, texture_point);
 
-      // Blur
-     //  vec4 color =   
-     //     texture2D(u_image, v_texCoord + onePixel * vec2(-4.0*hstep, -4.0*vstep)) * u_kernel[0] +
-     //     texture2D(u_image, v_texCoord + onePixel * vec2(-3.0*hstep, -3.0*vstep)) * u_kernel[1] +
-     //     texture2D(u_image, v_texCoord + onePixel * vec2(-2.0*hstep, -2.0*vstep)) * u_kernel[2] +
-     //     texture2D(u_image, v_texCoord + onePixel * vec2(-1.0*hstep, -1.0*vstep)) * u_kernel[3] +
-     //     texture2D(u_image, v_texCoord + onePixel * vec2( 0.0,  0.0)) * u_kernel[4] +
-     //     texture2D(u_image, v_texCoord + onePixel * vec2( 1.0*hstep,  1.0*vstep)) * u_kernel[5] +
-     //     texture2D(u_image, v_texCoord + onePixel * vec2( 2.0*hstep,  2.0*vstep)) * u_kernel[6] +
-     //     texture2D(u_image, v_texCoord + onePixel * vec2( 3.0*hstep,  3.0*vstep)) * u_kernel[7] + 
-     //     texture2D(u_image, v_texCoord + onePixel * vec2( 4.0*hstep,  4.0*vstep)) * u_kernel[8];
-     // 
-     // color = color/u_kernelWeight;
       // color.a = smoothstep(0.00, 0.01, color.r + color.g + color.b);
       color.a = min(0.8, color.a); //set variable here for opacity
-      // color.a = step(0.01, color.r + color.g + color.b); // remove black and make it transparent
+      // // color.a = step(0.01, color.r + color.g + color.b); // remove black and make it transparent
       color.b = v_texCoord.x;
       color.g = v_texCoord.y;
+      color.r = 0.0;
+      color.rgb = color.rgb * color.a;
       
       gl_FragColor = color;
     }
   </script>
+  
   <script id="2d-fragment-shader-spin" type="x-shader/x-fragment">
     precision lowp float;
     
@@ -238,6 +280,7 @@
   </script>
   
   <script src="gl-matrix.js"></script>
+  <script src="utils.js"></script>
   <script src="app.js"></script>
 </body>
 </html>
diff --git a/using-utils.js b/using-utils.js
new file mode 100644
index 0000000..9f91cce
--- /dev/null
+++ b/using-utils.js
@@ -0,0 +1,509 @@
+"use strict"
+
+
+
+// Entrypoint
+function initDemo() {
+  var canvas = document.getElementById("canvas");
+  var gl = canvas.getContext("webgl");
+  if (!gl) {
+    return;
+  }
+
+   webglUtils.resizeCanvasToDisplaySize(gl.canvas);
+
+  var program = webglUtils.createProgramFromScripts(gl, ["2d-vertex-shader", "2d-fragment-shader"]);
+  var blurProgram =  webglUtils.createProgramFromScripts(gl, ["2d-vertex-shader", "2d-fragment-shader-blur"]);
+  var spinProgram =  webglUtils.createProgramFromScripts(gl, ["2d-vertex-shader-spin", "2d-fragment-shader-spin"]);
+
+  // look up where the vertex data needs to go.
+  var positionLocation = gl.getAttribLocation(program, "a_position");
+  var texcoordLocation = gl.getAttribLocation(program, "a_texCoord");
+
+  // Create a buffer to put three 2d clip space points in
+  var positionBuffer = gl.createBuffer();
+  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+  
+  // Set a rectangle the same size as the canvas.
+  setRectangle(gl, 0, 0, canvas.clientWidth, canvas.clientHeight);
+
+  // provide texture coordinates for the rectangle.
+  var texcoordBuffer = gl.createBuffer();
+  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
+  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
+      0.0,  0.0,
+      1.0,  0.0,
+      0.0,  1.0,
+      0.0,  1.0,
+      1.0,  0.0,
+      1.0,  1.0,
+  ]), gl.STATIC_DRAW);
+
+  // lookup uniforms
+  var uniformSettersDefault = webglUtils.createUniformSetters(gl, program);
+  var uniformSettersBlur = webglUtils.createUniformSetters(gl, blurProgram);
+  
+  var resolutionLocation = gl.getUniformLocation(program, "u_resolution");
+  var imageLocation = gl.getUniformLocation(program, "u_image");
+  var offsetLocation = gl.getUniformLocation(program, "u_offset");
+  var widthLocation = gl.getUniformLocation(program, "u_width");
+  // var timeLocation = gl.getUniformLocation(program, "u_time");
+  
+  // Blur Uniforms
+  var blurImageLocation = gl.getUniformLocation(blurProgram, "u_image");
+  var kernelLocation = gl.getUniformLocation(blurProgram, "u_kernel[0]");
+  var directionLocation =  gl.getUniformLocation(blurProgram, "dir");
+
+  // Tell WebGL how to convert from clip space to pixels
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+  // Clear the canvas
+  gl.clearColor(0, 0, 0, 0);
+  gl.clear(gl.COLOR_BUFFER_BIT);
+
+  // Tell it to use our program (pair of shaders)
+  gl.useProgram(blurProgram);
+
+  gl.enableVertexAttribArray(positionLocation);
+  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+
+  // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
+  var size = 2;          // 2 components per iteration
+  var type = gl.FLOAT;   // the data is 32bit floats
+  var normalize = false; // don't normalize the data
+  var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
+  var offset = 0;        // start at the beginning of the buffer
+  gl.vertexAttribPointer(
+      positionLocation, size, type, normalize, stride, offset);
+
+  gl.enableVertexAttribArray(texcoordLocation);
+  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
+
+
+  var size = 2;          // 2 components per iteration
+  var type = gl.FLOAT;   // the data is 32bit floats
+  var normalize = false; // don't normalize the data
+  var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
+  var offset = 0;        // start at the beginning of the buffer
+  gl.vertexAttribPointer(
+      texcoordLocation, size, type, normalize, stride, offset);
+
+  // set the resolution
+  gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
+  
+  var createAndSetupTexture = function () {
+    var texture = gl.createTexture();
+    gl.bindTexture(gl.TEXTURE_2D, texture);
+    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
+    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
+    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
+    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
+    return texture;
+  }
+  
+
+  var image = new Image();
+  image.src = "./all-wavesa.png";
+  image.width = 10000;
+  image.height = 2048;
+  image.onload = function () {
+    var originalImageTexture = createAndSetupTexture();
+    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
+    
+    var framebuffers = [];
+    var gb2pass = [
+        0.110536,
+        0.110967,
+        0.111275,
+        0.111461,
+        0.111523,
+        0.111461,
+        0.111275,
+        0.110967,
+        0.110536
+      ]
+    
+    var frameBufferTexture = createAndSetupTexture();
+    // make the texture the same size as the image
+    gl.texImage2D(
+        gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0,
+        gl.RGBA, gl.UNSIGNED_BYTE, null);
+    // Create a framebuffer
+    var frameBuffer = gl.createFramebuffer();
+    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
+
+    // Attach a texture to it.
+    gl.framebufferTexture2D(
+      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, frameBufferTexture, 0);
+
+    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
+    gl.enable(gl.BLEND);
+    gl.disable(gl.DEPTH_TEST);
+
+    gl.uniform1i(imageLocation, 0);
+    gl.uniform1f(widthLocation, .123); // Width of each image
+    
+    let blurWaves = function(time) {
+      // gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
+      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+      gl.bindTexture(gl.TEXTURE_2D, originalImageTexture);
+      
+      gl.uniform2f(directionLocation, 0.0, 1.0);
+      gl.uniform2f(textureSizeLocation, image.width, image.height);
+      gl.uniform1fv(kernelLocation, gb2pass);
+      gl.uniform1i(blurImageLocation, 0);
+      
+      let uniforms = {
+        u_offset: 0.0,
+        u_x_scale_base: 1.0,
+        u_y_scale_base: 1.0,
+        u_x_scale_varience: 0.0,
+        u_y_scale_varience: 0.0,
+        u_x_skew_varience: 0.0,
+        u_y_skew_varience: 0.0,
+        u_x_coord: 0.0,
+        u_y_coord: 0.0,
+        u_x_translate: 0.0,
+        u_y_translate: 0.0,
+        u_time: time,
+        u_kernelWeight: 1.0,
+      }
+      webglUtils.setUniforms(uniformSettersBlur, uniforms);
+      gl.drawArrays(gl.TRIANGLES, 0, 6);
+      console.log("drawn to framebuffer")
+    } 
+     
+    let drawWaves = function (time, movement) {
+      let uniforms = {
+         u_offset:        movement.texture_offset,
+         u_x_scale_base:  movement.xScaleBase,
+         u_y_scale_base:  movement.yScaleBase,
+         u_x_scale_varience:  movement.xScaleVarience,
+         u_y_scale_varience:  movement.yScaleVarience,
+         u_x_skew_varience: movement.xSkewVarience,
+         u_y_skew_varience: movement.ySkewVarience,
+         u_x_coord: movement.initialX,
+         u_y_coord: movement.initialY,
+         u_x_translate: movement.translateX,
+         u_y_translate: movement.translateY,
+         u_time: ((time * movement.speed) + movement.delay) % movement.period
+      }
+      webglUtils.setUniforms(uniformSettersDefault, uniforms);
+      gl.drawArrays(gl.TRIANGLES, 0, 6);
+      console.log("drawn to screen")
+    }
+    
+    let wave1Movement = {
+      xScaleBase: 1.45,
+      yScaleBase: 1.5,
+      xScaleVarience: 0.1,
+      yScaleVarience: 0.1,
+      xSkewVarience: 0.0,
+      ySkewVarience: 0.0,
+      initialX: 0.0,
+      initialY: 0.1,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.0015,
+      texture_offset: 0.0,
+      period: 11,
+      
+      spin_delay: -1.0,
+      spin_radians: 4.0,
+      spin_translateX: 0.9,
+      spin_translateY: 1.4,
+      spin_speed: 0.002,
+    }
+    let wave2Movement = {
+      xScaleBase: 1.4,
+      yScaleBase: 1.3,
+      xScaleVarience: 0.1,
+      yScaleVarience: 0.1,
+      xSkewVarience: 0.0,
+      ySkewVarience: 0.0,
+      initialX: 0.0,
+      initialY: -0.3,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.0016,
+      texture_offset: 0.124,
+      period: 11,
+      
+      spin_delay: -1.0,
+      spin_radians: 0.0,
+      spin_translateX: 0.1,
+      spin_translateY: -0.8,
+      spin_speed: 0.0028,
+    }
+    let wave3Movement = {
+      xScaleBase: 1.3,
+      yScaleBase: 0.6,
+      xScaleVarience: 0.2,
+      yScaleVarience: 0.0,
+      xSkewVarience: 0.3,
+      ySkewVarience: 0.0,
+      initialX: 0.0,
+      initialY: -0.5,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.0011,
+      texture_offset: 0.2495,
+      period: 11,
+      
+      spin_delay: -1.0,
+      spin_radians: 2.1,
+      spin_translateX: 0.25,
+      spin_translateY: 0.25,
+      spin_speed: 0.0027,
+    }
+    let wave4Movement = {
+      xScaleBase: 1.3,
+      yScaleBase: 1.2,
+      xScaleVarience: 0.0,
+      yScaleVarience: -0.1,
+      xSkewVarience: -0.1,
+      ySkewVarience: 0.0,
+      initialX: 0.0,
+      initialY: -0.8,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.00018,
+      texture_offset: 0.3735,
+      period: 11,
+      
+      spin_delay: -1.0,
+      spin_radians: 0.5,
+      spin_translateX: 0.4,
+      spin_translateY: -0.3,
+      spin_speed: 0.0026,
+    }
+    
+    let wave5Movement = {
+      xScaleBase: 1.7,
+      yScaleBase: 0.5,
+      xScaleVarience: -0.2,
+      yScaleVarience: 0.1,
+      xSkewVarience: 0.3,
+      ySkewVarience: 0.0,
+      initialX: 0.15,
+      initialY: 0.15,
+      translateX: 0.0,
+      translateY: -0.1,
+      delay: 3.2,
+      speed: 0.0005,
+      texture_offset: 0.4965,
+      period: (4 * Math.PI),
+      
+      spin_delay: -1.0,
+      spin_radians: 1.4,
+      spin_translateX: 0.8,
+      spin_translateY: -0.3,
+      spin_speed: 0.0025,
+    }
+    
+    let wave6Movement = {
+      xScaleBase: 1.5,
+      yScaleBase: 1.3,
+      xScaleVarience: 0.15,
+      yScaleVarience: 0.15,
+      xSkewVarience: 0.2,
+      ySkewVarience: 0.0,
+      initialX: 0.0,
+      initialY: 0.4,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.00048,
+      texture_offset: 0.6215,
+      period: (4 * Math.PI),
+      
+      spin_delay: -1.0,
+      spin_radians: 2.0,
+      spin_translateX: -0.6,
+      spin_translateY: -0.0,
+      spin_speed: 0.0026,
+    }
+    
+    let wave7Movement = {
+      xScaleBase: 0.8,
+      yScaleBase: 1.0,
+      xScaleVarience: 0.1,
+      yScaleVarience: 0.25,
+      xSkewVarience: 0.15,
+      ySkewVarience: 0.0,
+      initialX: 0.3,
+      initialY: 0.4,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.0006,
+      texture_offset: 0.747,
+      period: (4 * Math.PI),
+      
+      spin_delay: -1.0,
+      spin_radians: 3.0,
+      spin_translateX: -0.4,
+      spin_translateY: -0.2,
+      spin_speed: 0.0025,
+    }
+    
+    let wave8Movement = {
+      xScaleBase: 1.5,
+      yScaleBase: 0.8,
+      xScaleVarience: 0.0,
+      yScaleVarience: -0.05,
+      xSkewVarience: 0.2,
+      ySkewVarience: 0.0,
+      initialX: -0.11,
+      initialY: 0.3,
+      translateX: 0.0,
+      translateY: 0.0,
+      delay: 3.2,
+      speed: 0.00051,
+      texture_offset: 0.877,
+      period: (4 * Math.PI),
+      
+      spin_delay: -1.0,
+      spin_radians: 2.0,
+      spin_translateX: -0.4,
+      spin_translateY: -0.1,
+      spin_speed: 0.002,
+    }
+    
+    let myReq;
+    let oldTime = 0;
+    let waveStartTime = performance.now();
+    let waveDeltaTime = 0;
+    console.log(image.width, image.height);
+    
+    gl.useProgram(blurProgram);
+    var textureSizeLocation = gl.getUniformLocation(blurProgram, "u_textureSize");
+    
+    let animate = function (time) {
+      waveDeltaTime = time - waveStartTime;
+      console.log("animate");
+      
+      webglUtils.resizeCanvasToDisplaySize(gl.canvas);
+      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+      blurWaves(waveDeltaTime);
+  
+      // gl.useProgram(program);
+      // webglUtils.resizeCanvasToDisplaySize(gl.canvas);
+      // gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+      // 
+      // gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+      // gl.bindTexture(gl.TEXTURE_2D, frameBufferTexture);  
+      // // gl.uniform2f(directionLocation, 1.0, 0.0);
+      // // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+      // drawWaves(waveDeltaTime, wave1Movement);
+      // drawWaves(waveDeltaTime, wave2Movement);
+      // drawWaves(waveDeltaTime, wave3Movement);
+      // drawWaves(waveDeltaTime, wave4Movement);
+      // drawWaves(waveDeltaTime, wave5Movement);
+      // drawWaves(waveDeltaTime, wave6Movement);
+      // drawWaves(waveDeltaTime, wave7Movement);
+      // drawWaves(waveDeltaTime, wave8Movement);
+    
+      // myReq = window.requestAnimationFrame(animate);
+    }
+    requestAnimationFrame(animate);
+    
+    // Change to rotation/spin shaders on keypress
+    // function handleKeyUp () {
+    //   gl.useProgram(spinProgram);
+    // 
+    //   var spinResolutionLocation = gl.getUniformLocation(spinProgram, "u_resolution");
+    //   var spinTimeLocation = gl.getUniformLocation(spinProgram, "u_time");
+    //   var spinDegreesLocation = gl.getUniformLocation(spinProgram, "u_degrees");
+    //   var spinXTranslateLocation = gl.getUniformLocation(spinProgram, "u_x_spin_translate");
+    //   var spinYTranslateLocation = gl.getUniformLocation(spinProgram, "u_y_spin_translate");
+    //   var spinFragTimeLocation = gl.getUniformLocation(spinProgram, "u_spin_time");
+    //   var endTimeLocation = gl.getUniformLocation(spinProgram, "u_old_end_time");
+    // 
+    //   var spinWidthLocation = gl.getUniformLocation(spinProgram, "u_width");
+    //   var spinOffsetLocation = gl.getUniformLocation(spinProgram, "u_offset");
+    //   var spinResolutionLocation = gl.getUniformLocation(spinProgram, "u_resolution");
+    //   var spinInitialXLocation = gl.getUniformLocation(spinProgram, "u_x_coord");
+    //   var spinInitialYLocation = gl.getUniformLocation(spinProgram, "u_y_coord");
+    //   var spinXScaleBaseLocation = gl.getUniformLocation(spinProgram, "u_x_scale_base");
+    //   var spinYScaleBaseLocation = gl.getUniformLocation(spinProgram, "u_y_scale_base");
+    //   var spinXScaleVarienceLocation = gl.getUniformLocation(spinProgram, "u_x_scale_varience");
+    //   var spinYScaleVarienceLocation = gl.getUniformLocation(spinProgram, "u_y_scale_varience");
+    //   var spinXSkewVarienceLocation = gl.getUniformLocation(spinProgram, "u_x_skew_varience");
+    //   var spinYSkewVarienceLocation = gl.getUniformLocation(spinProgram, "u_y_skew_varience");
+    //   var spinOldXTranslateLocation = gl.getUniformLocation(spinProgram, "u_x_translate");
+    //   var spinOldYTranslateLocation = gl.getUniformLocation(spinProgram, "u_y_translate");
+    //   var spinImageLocation = gl.getUniformLocation(spinProgram, "u_image");
+    // 
+    //   gl.uniform2f(spinResolutionLocation, gl.canvas.width, gl.canvas.height);
+    //   gl.uniform1i(spinImageLocation, 0);
+    //   gl.uniform1f(spinWidthLocation, .123);
+    // 
+    //   function drawWaveSpin (time, movement) {
+    //     // old wave uniforms
+    //     gl.uniform1f(spinOffsetLocation, movement.texture_offset);
+    //     gl.uniform1f(spinXScaleBaseLocation, movement.xScaleBase);
+    //     gl.uniform1f(spinYScaleBaseLocation, movement.yScaleBase);
+    //     gl.uniform1f(spinXScaleVarienceLocation, movement.xScaleVarience);
+    //     gl.uniform1f(spinYScaleVarienceLocation, movement.yScaleVarience);
+    //     gl.uniform1f(spinXSkewVarienceLocation, movement.xSkewVarience);
+    //     gl.uniform1f(spinYSkewVarienceLocation, movement.ySkewVarience);
+    //     gl.uniform1f(spinInitialXLocation, movement.initialX);
+    //     gl.uniform1f(spinInitialYLocation, movement.initialY);
+    //     gl.uniform1f(spinOldXTranslateLocation, movement.translateX);
+    //     gl.uniform1f(spinOldYTranslateLocation, movement.translateY);
+    // 
+    //     // spin uniforms
+    //     gl.uniform1f(spinXTranslateLocation, movement.spin_translateX);
+    //     gl.uniform1f(spinYTranslateLocation, movement.spin_translateY);
+    //     gl.uniform1f(spinDegreesLocation, movement.spin_radians);
+    //     gl.uniform1f(endTimeLocation, ((waveDeltaTime * movement.speed) + movement.delay) % movement.period);
+    // 
+    //     gl.uniform1f(spinTimeLocation, (time * movement.spin_speed) + movement.spin_delay);
+    //     gl.uniform1f(spinFragTimeLocation, (time * movement.spin_speed) + -1.0);
+    //     gl.drawArrays(gl.TRIANGLES, 0, 6);
+    //   }
+    // 
+    //   var deltaTime = 0;
+    //   var startTime = performance.now();
+    //   function spinOutAnimation(time) {
+    //     deltaTime = time-startTime;
+    //     gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+    //     drawWaveSpin(deltaTime, wave1Movement);
+    //     drawWaveSpin(deltaTime, wave2Movement);
+    //     drawWaveSpin(deltaTime, wave3Movement);
+    //     drawWaveSpin(deltaTime, wave4Movement);
+    //     drawWaveSpin(deltaTime, wave5Movement);
+    //     drawWaveSpin(deltaTime, wave6Movement);
+    //     drawWaveSpin(deltaTime, wave7Movement);
+    //     drawWaveSpin(deltaTime, wave8Movement);
+    //     window.requestAnimationFrame(spinOutAnimation);
+    //   }
+    // 
+    //   cancelAnimationFrame(myReq);
+    //   spinOutAnimation(startTime);
+    // }
+    // document.onkeyup = handleKeyUp;
+  }
+}
+
+
+function setRectangle(gl, x, y, width, height) {
+  var x1 = x;
+  var x2 = x + width;
+  var y1 = y;
+  var y2 = y + height;
+  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
+     x1, y1,
+     x2, y1,
+     x1, y2,
+     x1, y2,
+     x2, y1,
+     x2, y2,
+  ]), gl.STATIC_DRAW);
+}
diff --git a/utils.js b/utils.js
new file mode 100644
index 0000000..568680a
--- /dev/null
+++ b/utils.js
@@ -0,0 +1,1290 @@
+/*
+ * Copyright 2012, Gregg Tavares.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Gregg Tavares. nor the names of his
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+(function(root, factory) {  // eslint-disable-line
+  if (typeof define === 'function' && define.amd) {
+    // AMD. Register as an anonymous module.
+    define([], function() {
+      return factory.call(root);
+    });
+  } else {
+    // Browser globals
+    root.webglUtils = factory.call(root);
+  }
+}(this, function() {
+  "use strict";
+
+  var topWindow = this;
+
+  /** @module webgl-utils */
+
+  function isInIFrame(w) {
+    w = w || topWindow;
+    return w !== w.top;
+  }
+
+  if (!isInIFrame()) {
+    console.log("%c%s", 'color:blue;font-weight:bold;', 'for more about webgl-utils.js see:');  // eslint-disable-line
+    console.log("%c%s", 'color:blue;font-weight:bold;', 'http://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html');  // eslint-disable-line
+  }
+
+  /**
+   * Wrapped logging function.
+   * @param {string} msg The message to log.
+   */
+  function error(msg) {
+    if (topWindow.console) {
+      if (topWindow.console.error) {
+        topWindow.console.error(msg);
+      } else if (topWindow.console.log) {
+        topWindow.console.log(msg);
+      }
+    }
+  }
+
+
+  /**
+   * Error Callback
+   * @callback ErrorCallback
+   * @param {string} msg error message.
+   * @memberOf module:webgl-utils
+   */
+
+
+  /**
+   * Loads a shader.
+   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
+   * @param {string} shaderSource The shader source.
+   * @param {number} shaderType The type of shader.
+   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.
+   * @return {WebGLShader} The created shader.
+   */
+  function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {
+    var errFn = opt_errorCallback || error;
+    // Create the shader object
+    var shader = gl.createShader(shaderType);
+
+    // Load the shader source
+    gl.shaderSource(shader, shaderSource);
+
+    // Compile the shader
+    gl.compileShader(shader);
+
+    // Check the compile status
+    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
+    if (!compiled) {
+      // Something went wrong during compilation; get the error
+      var lastError = gl.getShaderInfoLog(shader);
+      errFn("*** Error compiling shader '" + shader + "':" + lastError);
+      gl.deleteShader(shader);
+      return null;
+    }
+
+    return shader;
+  }
+
+  /**
+   * Creates a program, attaches shaders, binds attrib locations, links the
+   * program and calls useProgram.
+   * @param {WebGLShader[]} shaders The shaders to attach
+   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in
+   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
+   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
+   *        on error. If you want something else pass an callback. It's passed an error message.
+   * @memberOf module:webgl-utils
+   */
+  function createProgram(
+      gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {
+    var errFn = opt_errorCallback || error;
+    var program = gl.createProgram();
+    shaders.forEach(function(shader) {
+      gl.attachShader(program, shader);
+    });
+    if (opt_attribs) {
+      opt_attribs.forEach(function(attrib, ndx) {
+        gl.bindAttribLocation(
+            program,
+            opt_locations ? opt_locations[ndx] : ndx,
+            attrib);
+      });
+    }
+    gl.linkProgram(program);
+
+    // Check the link status
+    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
+    if (!linked) {
+        // something went wrong with the link
+        var lastError = gl.getProgramInfoLog(program);
+        errFn("Error in program linking:" + lastError);
+
+        gl.deleteProgram(program);
+        return null;
+    }
+    return program;
+  }
+
+  /**
+   * Loads a shader from a script tag.
+   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
+   * @param {string} scriptId The id of the script tag.
+   * @param {number} opt_shaderType The type of shader. If not passed in it will
+   *     be derived from the type of the script tag.
+   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.
+   * @return {WebGLShader} The created shader.
+   */
+  function createShaderFromScript(
+      gl, scriptId, opt_shaderType, opt_errorCallback) {
+    var shaderSource = "";
+    var shaderType;
+    var shaderScript = document.getElementById(scriptId);
+    if (!shaderScript) {
+      throw ("*** Error: unknown script element" + scriptId);
+    }
+    shaderSource = shaderScript.text;
+
+    if (!opt_shaderType) {
+      if (shaderScript.type === "x-shader/x-vertex") {
+        shaderType = gl.VERTEX_SHADER;
+      } else if (shaderScript.type === "x-shader/x-fragment") {
+        shaderType = gl.FRAGMENT_SHADER;
+      } else if (shaderType !== gl.VERTEX_SHADER && shaderType !== gl.FRAGMENT_SHADER) {
+        throw ("*** Error: unknown shader type");
+      }
+    }
+
+    return loadShader(
+        gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,
+        opt_errorCallback);
+  }
+
+  var defaultShaderType = [
+    "VERTEX_SHADER",
+    "FRAGMENT_SHADER",
+  ];
+
+  /**
+   * Creates a program from 2 script tags.
+   *
+   * @param {WebGLRenderingContext} gl The WebGLRenderingContext
+   *        to use.
+   * @param {string[]} shaderScriptIds Array of ids of the script
+   *        tags for the shaders. The first is assumed to be the
+   *        vertex shader, the second the fragment shader.
+   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in
+   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
+   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
+   *        on error. If you want something else pass an callback. It's passed an error message.
+   * @return {WebGLProgram} The created program.
+   * @memberOf module:webgl-utils
+   */
+  function createProgramFromScripts(
+      gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {
+    var shaders = [];
+    for (var ii = 0; ii < shaderScriptIds.length; ++ii) {
+      shaders.push(createShaderFromScript(
+          gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], opt_errorCallback));
+    }
+    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);
+  }
+
+  /**
+   * Creates a program from 2 sources.
+   *
+   * @param {WebGLRenderingContext} gl The WebGLRenderingContext
+   *        to use.
+   * @param {string[]} shaderSourcess Array of sources for the
+   *        shaders. The first is assumed to be the vertex shader,
+   *        the second the fragment shader.
+   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in
+   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
+   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
+   *        on error. If you want something else pass an callback. It's passed an error message.
+   * @return {WebGLProgram} The created program.
+   * @memberOf module:webgl-utils
+   */
+  function createProgramFromSources(
+      gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
+    var shaders = [];
+    for (var ii = 0; ii < shaderSources.length; ++ii) {
+      shaders.push(loadShader(
+          gl, shaderSources[ii], gl[defaultShaderType[ii]], opt_errorCallback));
+    }
+    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);
+  }
+
+  /**
+   * Returns the corresponding bind point for a given sampler type
+   */
+  function getBindPointForSamplerType(gl, type) {
+    if (type === gl.SAMPLER_2D)   return gl.TEXTURE_2D;        // eslint-disable-line
+    if (type === gl.SAMPLER_CUBE) return gl.TEXTURE_CUBE_MAP;  // eslint-disable-line
+    return undefined;
+  }
+
+  /**
+   * @typedef {Object.<string, function>} Setters
+   */
+
+  /**
+   * Creates setter functions for all uniforms of a shader
+   * program.
+   *
+   * @see {@link module:webgl-utils.setUniforms}
+   *
+   * @param {WebGLProgram} program the program to create setters for.
+   * @returns {Object.<string, function>} an object with a setter by name for each uniform
+   * @memberOf module:webgl-utils
+   */
+  function createUniformSetters(gl, program) {
+    var textureUnit = 0;
+
+    /**
+     * Creates a setter for a uniform of the given program with it's
+     * location embedded in the setter.
+     * @param {WebGLProgram} program
+     * @param {WebGLUniformInfo} uniformInfo
+     * @returns {function} the created setter.
+     */
+    function createUniformSetter(program, uniformInfo) {
+      var location = gl.getUniformLocation(program, uniformInfo.name);
+      var type = uniformInfo.type;
+      // Check if this uniform is an array
+      var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === "[0]");
+      if (type === gl.FLOAT && isArray) {
+        return function(v) {
+          gl.uniform1fv(location, v);
+        };
+      }
+      if (type === gl.FLOAT) {
+        return function(v) {
+          gl.uniform1f(location, v);
+        };
+      }
+      if (type === gl.FLOAT_VEC2) {
+        return function(v) {
+          gl.uniform2fv(location, v);
+        };
+      }
+      if (type === gl.FLOAT_VEC3) {
+        return function(v) {
+          gl.uniform3fv(location, v);
+        };
+      }
+      if (type === gl.FLOAT_VEC4) {
+        return function(v) {
+          gl.uniform4fv(location, v);
+        };
+      }
+      if (type === gl.INT && isArray) {
+        return function(v) {
+          gl.uniform1iv(location, v);
+        };
+      }
+      if (type === gl.INT) {
+        return function(v) {
+          gl.uniform1i(location, v);
+        };
+      }
+      if (type === gl.INT_VEC2) {
+        return function(v) {
+          gl.uniform2iv(location, v);
+        };
+      }
+      if (type === gl.INT_VEC3) {
+        return function(v) {
+          gl.uniform3iv(location, v);
+        };
+      }
+      if (type === gl.INT_VEC4) {
+        return function(v) {
+          gl.uniform4iv(location, v);
+        };
+      }
+      if (type === gl.BOOL) {
+        return function(v) {
+          gl.uniform1iv(location, v);
+        };
+      }
+      if (type === gl.BOOL_VEC2) {
+        return function(v) {
+          gl.uniform2iv(location, v);
+        };
+      }
+      if (type === gl.BOOL_VEC3) {
+        return function(v) {
+          gl.uniform3iv(location, v);
+        };
+      }
+      if (type === gl.BOOL_VEC4) {
+        return function(v) {
+          gl.uniform4iv(location, v);
+        };
+      }
+      if (type === gl.FLOAT_MAT2) {
+        return function(v) {
+          gl.uniformMatrix2fv(location, false, v);
+        };
+      }
+      if (type === gl.FLOAT_MAT3) {
+        return function(v) {
+          gl.uniformMatrix3fv(location, false, v);
+        };
+      }
+      if (type === gl.FLOAT_MAT4) {
+        return function(v) {
+          gl.uniformMatrix4fv(location, false, v);
+        };
+      }
+      if ((type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) && isArray) {
+        var units = [];
+        for (var ii = 0; ii < info.size; ++ii) {
+          units.push(textureUnit++);
+        }
+        return function(bindPoint, units) {
+          return function(textures) {
+            gl.uniform1iv(location, units);
+            textures.forEach(function(texture, index) {
+              gl.activeTexture(gl.TEXTURE0 + units[index]);
+              gl.bindTexture(bindPoint, texture);
+            });
+          };
+        }(getBindPointForSamplerType(gl, type), units);
+      }
+      if (type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) {
+        return function(bindPoint, unit) {
+          return function(texture) {
+            gl.uniform1i(location, unit);
+            gl.activeTexture(gl.TEXTURE0 + unit);
+            console.log(texture, location, unit, type)
+            gl.bindTexture(bindPoint, texture);
+          };
+        }(getBindPointForSamplerType(gl, type), textureUnit++);
+      }
+      throw ("unknown type: 0x" + type.toString(16)); // we should never get here.
+    }
+
+    var uniformSetters = { };
+    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
+
+    for (var ii = 0; ii < numUniforms; ++ii) {
+      var uniformInfo = gl.getActiveUniform(program, ii);
+      if (!uniformInfo) {
+        break;
+      }
+      var name = uniformInfo.name;
+      // remove the array suffix.
+      if (name.substr(-3) === "[0]") {
+        name = name.substr(0, name.length - 3);
+      }
+      var setter = createUniformSetter(program, uniformInfo);
+      uniformSetters[name] = setter;
+    }
+    return uniformSetters;
+  }
+
+  /**
+   * Set uniforms and binds related textures.
+   *
+   * example:
+   *
+   *     var programInfo = createProgramInfo(
+   *         gl, ["some-vs", "some-fs");
+   *
+   *     var tex1 = gl.createTexture();
+   *     var tex2 = gl.createTexture();
+   *
+   *     ... assume we setup the textures with data ...
+   *
+   *     var uniforms = {
+   *       u_someSampler: tex1,
+   *       u_someOtherSampler: tex2,
+   *       u_someColor: [1,0,0,1],
+   *       u_somePosition: [0,1,1],
+   *       u_someMatrix: [
+   *         1,0,0,0,
+   *         0,1,0,0,
+   *         0,0,1,0,
+   *         0,0,0,0,
+   *       ],
+   *     };
+   *
+   *     gl.useProgram(program);
+   *
+   * This will automatically bind the textures AND set the
+   * uniforms.
+   *
+   *     setUniforms(programInfo.uniformSetters, uniforms);
+   *
+   * For the example above it is equivalent to
+   *
+   *     var texUnit = 0;
+   *     gl.activeTexture(gl.TEXTURE0 + texUnit);
+   *     gl.bindTexture(gl.TEXTURE_2D, tex1);
+   *     gl.uniform1i(u_someSamplerLocation, texUnit++);
+   *     gl.activeTexture(gl.TEXTURE0 + texUnit);
+   *     gl.bindTexture(gl.TEXTURE_2D, tex2);
+   *     gl.uniform1i(u_someSamplerLocation, texUnit++);
+   *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);
+   *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);
+   *     gl.uniformMatrix4fv(u_someMatrix, false, [
+   *         1,0,0,0,
+   *         0,1,0,0,
+   *         0,0,1,0,
+   *         0,0,0,0,
+   *       ]);
+   *
+   * Note it is perfectly reasonable to call `setUniforms` multiple times. For example
+   *
+   *     var uniforms = {
+   *       u_someSampler: tex1,
+   *       u_someOtherSampler: tex2,
+   *     };
+   *
+   *     var moreUniforms {
+   *       u_someColor: [1,0,0,1],
+   *       u_somePosition: [0,1,1],
+   *       u_someMatrix: [
+   *         1,0,0,0,
+   *         0,1,0,0,
+   *         0,0,1,0,
+   *         0,0,0,0,
+   *       ],
+   *     };
+   *
+   *     setUniforms(programInfo.uniformSetters, uniforms);
+   *     setUniforms(programInfo.uniformSetters, moreUniforms);
+   *
+   * @param {Object.<string, function>|module:webgl-utils.ProgramInfo} setters the setters returned from
+   *        `createUniformSetters` or a ProgramInfo from {@link module:webgl-utils.createProgramInfo}.
+   * @param {Object.<string, value>} an object with values for the
+   *        uniforms.
+   * @memberOf module:webgl-utils
+   */
+  function setUniforms(setters, values) {
+    setters = setters.uniformSetters || setters;
+    Object.keys(values).forEach(function(name) {
+      var setter = setters[name];
+      if (setter) {
+        setter(values[name]);
+      }
+    });
+  }
+
+  /**
+   * Creates setter functions for all attributes of a shader
+   * program. You can pass this to {@link module:webgl-utils.setBuffersAndAttributes} to set all your buffers and attributes.
+   *
+   * @see {@link module:webgl-utils.setAttributes} for example
+   * @param {WebGLProgram} program the program to create setters for.
+   * @return {Object.<string, function>} an object with a setter for each attribute by name.
+   * @memberOf module:webgl-utils
+   */
+  function createAttributeSetters(gl, program) {
+    var attribSetters = {
+    };
+
+    function createAttribSetter(index) {
+      return function(b) {
+          gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
+          gl.enableVertexAttribArray(index);
+          gl.vertexAttribPointer(
+              index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);
+        };
+    }
+
+    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
+    for (var ii = 0; ii < numAttribs; ++ii) {
+      var attribInfo = gl.getActiveAttrib(program, ii);
+      if (!attribInfo) {
+        break;
+      }
+      var index = gl.getAttribLocation(program, attribInfo.name);
+      attribSetters[attribInfo.name] = createAttribSetter(index);
+    }
+
+    return attribSetters;
+  }
+
+  /**
+   * Sets attributes and binds buffers (deprecated... use {@link module:webgl-utils.setBuffersAndAttributes})
+   *
+   * Example:
+   *
+   *     var program = createProgramFromScripts(
+   *         gl, ["some-vs", "some-fs");
+   *
+   *     var attribSetters = createAttributeSetters(program);
+   *
+   *     var positionBuffer = gl.createBuffer();
+   *     var texcoordBuffer = gl.createBuffer();
+   *
+   *     var attribs = {
+   *       a_position: {buffer: positionBuffer, numComponents: 3},
+   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
+   *     };
+   *
+   *     gl.useProgram(program);
+   *
+   * This will automatically bind the buffers AND set the
+   * attributes.
+   *
+   *     setAttributes(attribSetters, attribs);
+   *
+   * Properties of attribs. For each attrib you can add
+   * properties:
+   *
+   * *   type: the type of data in the buffer. Default = gl.FLOAT
+   * *   normalize: whether or not to normalize the data. Default = false
+   * *   stride: the stride. Default = 0
+   * *   offset: offset into the buffer. Default = 0
+   *
+   * For example if you had 3 value float positions, 2 value
+   * float texcoord and 4 value uint8 colors you'd setup your
+   * attribs like this
+   *
+   *     var attribs = {
+   *       a_position: {buffer: positionBuffer, numComponents: 3},
+   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
+   *       a_color: {
+   *         buffer: colorBuffer,
+   *         numComponents: 4,
+   *         type: gl.UNSIGNED_BYTE,
+   *         normalize: true,
+   *       },
+   *     };
+   *
+   * @param {Object.<string, function>|model:webgl-utils.ProgramInfo} setters Attribute setters as returned from createAttributeSetters or a ProgramInfo as returned {@link module:webgl-utils.createProgramInfo}
+   * @param {Object.<string, module:webgl-utils.AttribInfo>} attribs AttribInfos mapped by attribute name.
+   * @memberOf module:webgl-utils
+   * @deprecated use {@link module:webgl-utils.setBuffersAndAttributes}
+   */
+  function setAttributes(setters, attribs) {
+    setters = setters.attribSetters || setters;
+    Object.keys(attribs).forEach(function(name) {
+      var setter = setters[name];
+      if (setter) {
+        setter(attribs[name]);
+      }
+    });
+  }
+
+  /**
+   * Creates a vertex array object and then sets the attributes
+   * on it
+   *
+   * @param {WebGLRenderingContext} gl The WebGLRenderingContext
+   *        to use.
+   * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
+   * @param {Object.<string, module:webgl-utils.AttribInfo>} attribs AttribInfos mapped by attribute name.
+   * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
+   */
+  function createVAOAndSetAttributes(gl, setters, attribs, indices) {
+    var vao = gl.createVertexArray();
+    gl.bindVertexArray(vao);
+    setAttributes(setters, attribs);
+    if (indices) {
+      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);
+    }
+    // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER
+    // like when creating buffers for other stuff will mess up this VAO's binding
+    gl.bindVertexArray(null);
+    return vao;
+  }
+
+  /**
+   * Creates a vertex array object and then sets the attributes
+   * on it
+   *
+   * @param {WebGLRenderingContext} gl The WebGLRenderingContext
+   *        to use.
+   * @param {Object.<string, function>| module:webgl-utils.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters
+   * @param {module:webgl-utils:BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
+   * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
+   */
+  function createVAOFromBufferInfo(gl, programInfo, bufferInfo) {
+    return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);
+  }
+
+  /**
+   * @typedef {Object} ProgramInfo
+   * @property {WebGLProgram} program A shader program
+   * @property {Object<string, function>} uniformSetters: object of setters as returned from createUniformSetters,
+   * @property {Object<string, function>} attribSetters: object of setters as returned from createAttribSetters,
+   * @memberOf module:webgl-utils
+   */
+
+  /**
+   * Creates a ProgramInfo from 2 sources.
+   *
+   * A ProgramInfo contains
+   *
+   *     programInfo = {
+   *        program: WebGLProgram,
+   *        uniformSetters: object of setters as returned from createUniformSetters,
+   *        attribSetters: object of setters as returned from createAttribSetters,
+   *     }
+   *
+   * @param {WebGLRenderingContext} gl The WebGLRenderingContext
+   *        to use.
+   * @param {string[]} shaderSourcess Array of sources for the
+   *        shaders or ids. The first is assumed to be the vertex shader,
+   *        the second the fragment shader.
+   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in
+   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
+   * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console
+   *        on error. If you want something else pass an callback. It's passed an error message.
+   * @return {module:webgl-utils.ProgramInfo} The created program.
+   * @memberOf module:webgl-utils
+   */
+  function createProgramInfo(
+      gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
+    shaderSources = shaderSources.map(function(source) {
+      var script = document.getElementById(source);
+      return script ? script.text : source;
+    });
+    var program = webglUtils.createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback);
+    if (!program) {
+      return null;
+    }
+    var uniformSetters = createUniformSetters(gl, program);
+    var attribSetters = createAttributeSetters(gl, program);
+    return {
+      program: program,
+      uniformSetters: uniformSetters,
+      attribSetters: attribSetters,
+    };
+  }
+
+  /**
+   * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate
+   *
+   * Example:
+   *
+   *     var programInfo = createProgramInfo(
+   *         gl, ["some-vs", "some-fs");
+   *
+   *     var arrays = {
+   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
+   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
+   *     };
+   *
+   *     var bufferInfo = createBufferInfoFromArrays(gl, arrays);
+   *
+   *     gl.useProgram(programInfo.program);
+   *
+   * This will automatically bind the buffers AND set the
+   * attributes.
+   *
+   *     setBuffersAndAttributes(programInfo.attribSetters, bufferInfo);
+   *
+   * For the example above it is equivilent to
+   *
+   *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
+   *     gl.enableVertexAttribArray(a_positionLocation);
+   *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);
+   *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
+   *     gl.enableVertexAttribArray(a_texcoordLocation);
+   *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);
+   *
+   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
+   * @param {Object.<string, function>} setters Attribute setters as returned from `createAttributeSetters`
+   * @param {module:webgl-utils.BufferInfo} buffers a BufferInfo as returned from `createBufferInfoFromArrays`.
+   * @memberOf module:webgl-utils
+   */
+  function setBuffersAndAttributes(gl, setters, buffers) {
+    setAttributes(setters, buffers.attribs);
+    if (buffers.indices) {
+      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
+    }
+  }
+
+  // Add your prefix here.
+  var browserPrefixes = [
+    "",
+    "MOZ_",
+    "OP_",
+    "WEBKIT_",
+  ];
+
+  /**
+   * Given an extension name like WEBGL_compressed_texture_s3tc
+   * returns the supported version extension, like
+   * WEBKIT_WEBGL_compressed_teture_s3tc
+   * @param {string} name Name of extension to look for
+   * @return {WebGLExtension} The extension or undefined if not
+   *     found.
+   * @memberOf module:webgl-utils
+   */
+  function getExtensionWithKnownPrefixes(gl, name) {
+    for (var ii = 0; ii < browserPrefixes.length; ++ii) {
+      var prefixedName = browserPrefixes[ii] + name;
+      var ext = gl.getExtension(prefixedName);
+      if (ext) {
+        return ext;
+      }
+    }
+    return undefined;
+  }
+
+  /**
+   * Resize a canvas to match the size its displayed.
+   * @param {HTMLCanvasElement} canvas The canvas to resize.
+   * @param {number} [multiplier] amount to multiply by.
+   *    Pass in window.devicePixelRatio for native pixels.
+   * @return {boolean} true if the canvas was resized.
+   * @memberOf module:webgl-utils
+   */
+  function resizeCanvasToDisplaySize(canvas, multiplier) {
+    multiplier = multiplier || 1;
+    var width  = canvas.clientWidth  * multiplier | 0;
+    var height = canvas.clientHeight * multiplier | 0;
+    if (canvas.width !== width ||  canvas.height !== height) {
+      canvas.width  = width;
+      canvas.height = height;
+      return true;
+    }
+    return false;
+  }
+
+  // Add `push` to a typed array. It just keeps a 'cursor'
+  // and allows use to `push` values into the array so we
+  // don't have to manually compute offsets
+  function augmentTypedArray(typedArray, numComponents) {
+    var cursor = 0;
+    typedArray.push = function() {
+      for (var ii = 0; ii < arguments.length; ++ii) {
+        var value = arguments[ii];
+        if (value instanceof Array || (value.buffer && value.buffer instanceof ArrayBuffer)) {
+          for (var jj = 0; jj < value.length; ++jj) {
+            typedArray[cursor++] = value[jj];
+          }
+        } else {
+          typedArray[cursor++] = value;
+        }
+      }
+    };
+    typedArray.reset = function(opt_index) {
+      cursor = opt_index || 0;
+    };
+    typedArray.numComponents = numComponents;
+    Object.defineProperty(typedArray, 'numElements', {
+      get: function() {
+        return this.length / this.numComponents | 0;
+      },
+    });
+    return typedArray;
+  }
+
+  /**
+   * creates a typed array with a `push` function attached
+   * so that you can easily *push* values.
+   *
+   * `push` can take multiple arguments. If an argument is an array each element
+   * of the array will be added to the typed array.
+   *
+   * Example:
+   *
+   *     var array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values
+   *     array.push(1, 2, 3);
+   *     array.push([4, 5, 6]);
+   *     // array now contains [1, 2, 3, 4, 5, 6]
+   *
+   * Also has `numComponents` and `numElements` properties.
+   *
+   * @param {number} numComponents number of components
+   * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.
+   * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.
+   * @return {ArrayBuffer} A typed array.
+   * @memberOf module:webgl-utils
+   */
+  function createAugmentedTypedArray(numComponents, numElements, opt_type) {
+    var Type = opt_type || Float32Array;
+    return augmentTypedArray(new Type(numComponents * numElements), numComponents);
+  }
+
+  function createBufferFromTypedArray(gl, array, type, drawType) {
+    type = type || gl.ARRAY_BUFFER;
+    var buffer = gl.createBuffer();
+    gl.bindBuffer(type, buffer);
+    gl.bufferData(type, array, drawType || gl.STATIC_DRAW);
+    return buffer;
+  }
+
+  function allButIndices(name) {
+    return name !== "indices";
+  }
+
+  function createMapping(obj) {
+    var mapping = {};
+    Object.keys(obj).filter(allButIndices).forEach(function(key) {
+      mapping["a_" + key] = key;
+    });
+    return mapping;
+  }
+
+  function getGLTypeForTypedArray(gl, typedArray) {
+    if (typedArray instanceof Int8Array)    { return gl.BYTE; }            // eslint-disable-line
+    if (typedArray instanceof Uint8Array)   { return gl.UNSIGNED_BYTE; }   // eslint-disable-line
+    if (typedArray instanceof Int16Array)   { return gl.SHORT; }           // eslint-disable-line
+    if (typedArray instanceof Uint16Array)  { return gl.UNSIGNED_SHORT; }  // eslint-disable-line
+    if (typedArray instanceof Int32Array)   { return gl.INT; }             // eslint-disable-line
+    if (typedArray instanceof Uint32Array)  { return gl.UNSIGNED_INT; }    // eslint-disable-line
+    if (typedArray instanceof Float32Array) { return gl.FLOAT; }           // eslint-disable-line
+    throw "unsupported typed array type";
+  }
+
+  // This is really just a guess. Though I can't really imagine using
+  // anything else? Maybe for some compression?
+  function getNormalizationForTypedArray(typedArray) {
+    if (typedArray instanceof Int8Array)    { return true; }  // eslint-disable-line
+    if (typedArray instanceof Uint8Array)   { return true; }  // eslint-disable-line
+    return false;
+  }
+
+  function isArrayBuffer(a) {
+    return a.buffer && a.buffer instanceof ArrayBuffer;
+  }
+
+  function guessNumComponentsFromName(name, length) {
+    var numComponents;
+    if (name.indexOf("coord") >= 0) {
+      numComponents = 2;
+    } else if (name.indexOf("color") >= 0) {
+      numComponents = 4;
+    } else {
+      numComponents = 3;  // position, normals, indices ...
+    }
+
+    if (length % numComponents > 0) {
+      throw "can not guess numComponents. You should specify it.";
+    }
+
+    return numComponents;
+  }
+
+  function makeTypedArray(array, name) {
+    if (isArrayBuffer(array)) {
+      return array;
+    }
+
+    if (Array.isArray(array)) {
+      array = {
+        data: array,
+      };
+    }
+
+    if (!array.numComponents) {
+      array.numComponents = guessNumComponentsFromName(name, array.length);
+    }
+
+    var type = array.type;
+    if (!type) {
+      if (name === "indices") {
+        type = Uint16Array;
+      }
+    }
+    var typedArray = createAugmentedTypedArray(array.numComponents, array.data.length / array.numComponents | 0, type);
+    typedArray.push(array.data);
+    return typedArray;
+  }
+
+  /**
+   * @typedef {Object} AttribInfo
+   * @property {number} [numComponents] the number of components for this attribute.
+   * @property {number} [size] the number of components for this attribute.
+   * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`
+   * @property {boolean} [normalized] whether or not to normalize the data. Default = false
+   * @property {number} [offset] offset into buffer in bytes. Default = 0
+   * @property {number} [stride] the stride in bytes per element. Default = 0
+   * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute
+   * @memberOf module:webgl-utils
+   */
+
+
+  /**
+   * Creates a set of attribute data and WebGLBuffers from set of arrays
+   *
+   * Given
+   *
+   *      var arrays = {
+   *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
+   *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
+   *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
+   *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },
+   *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
+   *      };
+   *
+   * returns something like
+   *
+   *      var attribs = {
+   *        a_position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
+   *        a_texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
+   *        a_normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
+   *        a_color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },
+   *      };
+   *
+   * @param {WebGLRenderingContext} gl The webgl rendering context.
+   * @param {Object.<string, array|typedarray>} arrays The arrays
+   * @param {Object.<string, string>} [opt_mapping] mapping from attribute name to array name.
+   *     if not specified defaults to "a_name" -> "name".
+   * @return {Object.<string, module:webgl-utils.AttribInfo>} the attribs
+   * @memberOf module:webgl-utils
+   */
+  function createAttribsFromArrays(gl, arrays, opt_mapping) {
+    var mapping = opt_mapping || createMapping(arrays);
+    var attribs = {};
+    Object.keys(mapping).forEach(function(attribName) {
+      var bufferName = mapping[attribName];
+      var array = makeTypedArray(arrays[bufferName], bufferName);
+      attribs[attribName] = {
+        buffer:        createBufferFromTypedArray(gl, array),
+        numComponents: array.numComponents || guessNumComponentsFromName(bufferName),
+        type:          getGLTypeForTypedArray(gl, array),
+        normalize:     getNormalizationForTypedArray(array),
+      };
+    });
+    return attribs;
+  }
+
+  /**
+   * tries to get the number of elements from a set of arrays.
+   */
+  function getNumElementsFromNonIndexedArrays(arrays) {
+    var key = Object.keys(arrays)[0];
+    var array = arrays[key];
+    if (isArrayBuffer(array)) {
+      return array.numElements;
+    } else {
+      return array.data.length / array.numComponents;
+    }
+  }
+
+  /**
+   * @typedef {Object} BufferInfo
+   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
+   * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.
+   * @property {Object.<string, module:webgl-utils.AttribInfo>} attribs The attribs approriate to call `setAttributes`
+   * @memberOf module:webgl-utils
+   */
+
+
+  /**
+   * Creates a BufferInfo from an object of arrays.
+   *
+   * This can be passed to {@link module:webgl-utils.setBuffersAndAttributes} and to
+   * {@link module:webgl-utils:drawBufferInfo}.
+   *
+   * Given an object like
+   *
+   *     var arrays = {
+   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
+   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
+   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
+   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
+   *     };
+   *
+   *  Creates an BufferInfo like this
+   *
+   *     bufferInfo = {
+   *       numElements: 4,        // or whatever the number of elements is
+   *       indices: WebGLBuffer,  // this property will not exist if there are no indices
+   *       attribs: {
+   *         a_position: { buffer: WebGLBuffer, numComponents: 3, },
+   *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },
+   *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },
+   *       },
+   *     };
+   *
+   *  The properties of arrays can be JavaScript arrays in which case the number of components
+   *  will be guessed.
+   *
+   *     var arrays = {
+   *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],
+   *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],
+   *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
+   *        indices:  [0, 1, 2, 1, 2, 3],
+   *     };
+   *
+   *  They can also by TypedArrays
+   *
+   *     var arrays = {
+   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
+   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
+   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
+   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
+   *     };
+   *
+   *  Or augmentedTypedArrays
+   *
+   *     var positions = createAugmentedTypedArray(3, 4);
+   *     var texcoords = createAugmentedTypedArray(2, 4);
+   *     var normals   = createAugmentedTypedArray(3, 4);
+   *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);
+   *
+   *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);
+   *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);
+   *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
+   *     indices.push([0, 1, 2, 1, 2, 3]);
+   *
+   *     var arrays = {
+   *        position: positions,
+   *        texcoord: texcoords,
+   *        normal:   normals,
+   *        indices:  indices,
+   *     };
+   *
+   * For the last example it is equivalent to
+   *
+   *     var bufferInfo = {
+   *       attribs: {
+   *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },
+   *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },
+   *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },
+   *       },
+   *       indices: gl.createBuffer(),
+   *       numElements: 6,
+   *     };
+   *
+   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);
+   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);
+   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);
+   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);
+   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);
+   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);
+   *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);
+   *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);
+   *
+   * @param {WebGLRenderingContext} gl A WebGLRenderingContext
+   * @param {Object.<string, array|object|typedarray>} arrays Your data
+   * @param {Object.<string, string>} [opt_mapping] an optional mapping of attribute to array name.
+   *    If not passed in it's assumed the array names will be mapped to an attibute
+   *    of the same name with "a_" prefixed to it. An other words.
+   *
+   *        var arrays = {
+   *           position: ...,
+   *           texcoord: ...,
+   *           normal:   ...,
+   *           indices:  ...,
+   *        };
+   *
+   *        bufferInfo = createBufferInfoFromArrays(gl, arrays);
+   *
+   *    Is the same as
+   *
+   *        var arrays = {
+   *           position: ...,
+   *           texcoord: ...,
+   *           normal:   ...,
+   *           indices:  ...,
+   *        };
+   *
+   *        var mapping = {
+   *          a_position: "position",
+   *          a_texcoord: "texcoord",
+   *          a_normal:   "normal",
+   *        };
+   *
+   *        bufferInfo = createBufferInfoFromArrays(gl, arrays, mapping);
+   *
+   * @return {module:webgl-utils.BufferInfo} A BufferInfo
+   * @memberOf module:webgl-utils
+   */
+  function createBufferInfoFromArrays(gl, arrays, opt_mapping) {
+    var bufferInfo = {
+      attribs: createAttribsFromArrays(gl, arrays, opt_mapping),
+    };
+    var indices = arrays.indices;
+    if (indices) {
+      indices = makeTypedArray(indices, "indices");
+      bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);
+      bufferInfo.numElements = indices.length;
+    } else {
+      bufferInfo.numElements = getNumElementsFromNonIndexedArrays(arrays);
+    }
+
+    return bufferInfo;
+  }
+
+  /**
+   * Creates buffers from typed arrays
+   *
+   * Given something like this
+   *
+   *     var arrays = {
+   *        positions: [1, 2, 3],
+   *        normals: [0, 0, 1],
+   *     }
+   *
+   * returns something like
+   *
+   *     buffers = {
+   *       positions: WebGLBuffer,
+   *       normals: WebGLBuffer,
+   *     }
+   *
+   * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.
+   *
+   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
+   * @param {Object<string, array|typedarray>} arrays
+   * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array
+   * @memberOf module:webgl-utils
+   */
+  function createBuffersFromArrays(gl, arrays) {
+    var buffers = { };
+    Object.keys(arrays).forEach(function(key) {
+      var type = key === "indices" ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
+      var array = makeTypedArray(arrays[key], name);
+      buffers[key] = createBufferFromTypedArray(gl, array, type);
+    });
+
+    // hrm
+    if (arrays.indices) {
+      buffers.numElements = arrays.indices.length;
+    } else if (arrays.position) {
+      buffers.numElements = arrays.position.length / 3;
+    }
+
+    return buffers;
+  }
+
+  /**
+   * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate
+   *
+   * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself
+   * but calling this means if you switch from indexed data to non-indexed
+   * data you don't have to remember to update your draw call.
+   *
+   * @param {WebGLRenderingContext} gl A WebGLRenderingContext
+   * @param {module:webgl-utils.BufferInfo} bufferInfo as returned from createBufferInfoFromArrays
+   * @param {enum} [primitiveType] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...)
+   * @param {number} [count] An optional count. Defaults to bufferInfo.numElements
+   * @param {number} [offset] An optional offset. Defaults to 0.
+   * @memberOf module:webgl-utils
+   */
+  function drawBufferInfo(gl, bufferInfo, primitiveType, count, offset) {
+    var indices = bufferInfo.indices;
+    primitiveType = primitiveType === undefined ? gl.TRIANGLES : primitiveType;
+    var numElements = count === undefined ? bufferInfo.numElements : count;
+    offset = offset === undefined ? offset : 0;
+    if (indices) {
+      gl.drawElements(primitiveType, numElements, gl.UNSIGNED_SHORT, offset);
+    } else {
+      gl.drawArrays(primitiveType, offset, numElements);
+    }
+  }
+
+  /**
+   * @typedef {Object} DrawObject
+   * @property {module:webgl-utils.ProgramInfo} programInfo A ProgramInfo as returned from createProgramInfo
+   * @property {module:webgl-utils.BufferInfo} bufferInfo A BufferInfo as returned from createBufferInfoFromArrays
+   * @property {Object<string, ?>} uniforms The values for the uniforms
+   * @memberOf module:webgl-utils
+   */
+
+  /**
+   * Draws a list of objects
+   * @param {WebGLRenderingContext} gl A WebGLRenderingContext
+   * @param {DrawObject[]} objectsToDraw an array of objects to draw.
+   * @memberOf module:webgl-utils
+   */
+  function drawObjectList(gl, objectsToDraw) {
+    var lastUsedProgramInfo = null;
+    var lastUsedBufferInfo = null;
+
+    objectsToDraw.forEach(function(object) {
+      var programInfo = object.programInfo;
+      var bufferInfo = object.bufferInfo;
+      var bindBuffers = false;
+
+      if (programInfo !== lastUsedProgramInfo) {
+        lastUsedProgramInfo = programInfo;
+        gl.useProgram(programInfo.program);
+        bindBuffers = true;
+      }
+
+      // Setup all the needed attributes.
+      if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {
+        lastUsedBufferInfo = bufferInfo;
+        setBuffersAndAttributes(gl, programInfo.attribSetters, bufferInfo);
+      }
+
+      // Set the uniforms.
+      setUniforms(programInfo.uniformSetters, object.uniforms);
+
+      // Draw
+      drawBufferInfo(gl, bufferInfo);
+    });
+  }
+
+  var isIE = /*@cc_on!@*/false || !!document.documentMode;
+  // Edge 20+
+  var isEdge = !isIE && !!window.StyleMedia;
+  if (isEdge) {
+    // Hack for Edge. Edge's WebGL implmentation is crap still and so they
+    // only respond to "experimental-webgl". I don't want to clutter the
+    // examples with that so his hack works around it
+    HTMLCanvasElement.prototype.getContext = function(origFn) {
+      return function() {
+        var args = arguments;
+        var type = args[0];
+        if (type === "webgl") {
+          args = [].slice.call(arguments);
+          args[0] = "experimental-webgl";
+        }
+        return origFn.apply(this, args);
+      };
+    }(HTMLCanvasElement.prototype.getContext);
+  }
+
+  return {
+    createAugmentedTypedArray: createAugmentedTypedArray,
+    createAttribsFromArrays: createAttribsFromArrays,
+    createBuffersFromArrays: createBuffersFromArrays,
+    createBufferInfoFromArrays: createBufferInfoFromArrays,
+    createAttributeSetters: createAttributeSetters,
+    createProgram: createProgram,
+    createProgramFromScripts: createProgramFromScripts,
+    createProgramFromSources: createProgramFromSources,
+    createProgramInfo: createProgramInfo,
+    createUniformSetters: createUniformSetters,
+    createVAOAndSetAttributes: createVAOAndSetAttributes,
+    createVAOFromBufferInfo: createVAOFromBufferInfo,
+    drawBufferInfo: drawBufferInfo,
+    drawObjectList: drawObjectList,
+    getExtensionWithKnownPrefixes: getExtensionWithKnownPrefixes,
+    resizeCanvasToDisplaySize: resizeCanvasToDisplaySize,
+    setAttributes: setAttributes,
+    setBuffersAndAttributes: setBuffersAndAttributes,
+    setUniforms: setUniforms,
+  };
+
+}));
+
