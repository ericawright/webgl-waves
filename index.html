<!DOCTYPE html>
<html>
<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
  <meta content="utf-8" http-equiv="encoding">
  <title>webgl test</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body onload="InitDemo();">
  <canvas id="canvas">
    HTML5 is not supported.
  </canvas>
  <!-- <img src="wave1a.png"/> -->

  
  <!-- vertex shader -->
  <script id="2d-vertex-shader-spin" type="x-shader/x-vertex">
  precision lowp float;
  const float PI = 3.14159;

  attribute vec2 a_position;
  attribute vec2 a_texCoord;

  uniform vec2 u_resolution;
  uniform float u_time;
  uniform float u_y_spin_translate;
  uniform float u_x_spin_translate;
  uniform float u_degrees;
  
  uniform float u_old_end_time;
  uniform float u_x_coord;
  uniform float u_y_coord;
  uniform float u_y_scale_base;
  uniform float u_x_scale_base;
  uniform float u_y_scale_varience;
  uniform float u_x_scale_varience;
  uniform float u_y_skew_varience;
  uniform float u_x_skew_varience;
  uniform float u_y_translate;
  uniform float u_x_translate;
  
  varying vec2 v_texCoord;
  
  mat2 scale(vec2 _scale) {
    return mat2(_scale.x,0.0,
                0.0,_scale.y);
  }
  
  mat2 skew(vec2 _skew) {
    return mat2(1.0, _skew.x,
                _skew.y, 1.0);
  }
  
  mat2 rotate(float _angle){
    return mat2(cos(_angle),-sin(_angle),
                sin(_angle),cos(_angle));
  }

  
  void main() {
    // convert the rectangle from pixels to 0.0 to 1.0
    vec2 zeroToOne = a_position / u_resolution;
    
    zeroToOne -= vec2(0.5); //move to 0,0 to shift from
    
    // Do what was done by the old shader to start at the same position
    float oldTime = max(u_old_end_time, 3.0 * PI/2.0);
    oldTime = min(oldTime, 7.0 * PI/2.0);
    float y_scale = u_y_scale_base + u_y_scale_varience * (sin(oldTime) + 1.0);
    float x_scale = u_x_scale_base + u_x_scale_varience * (sin(oldTime) + 1.0);
    zeroToOne = scale(vec2(x_scale, y_scale)) * zeroToOne;
    
    float x_skew = u_x_skew_varience * (sin(oldTime) + 1.0);
    float y_skew = u_y_skew_varience * (sin(oldTime) + 1.0);
    zeroToOne = zeroToOne * skew(vec2(x_skew, y_skew));
    
    zeroToOne -= vec2(u_x_coord, u_y_coord); //initial positioning
    zeroToOne -= vec2(u_x_translate * (sin(oldTime) + 1.0), u_y_translate * (sin(oldTime) + 1.0));
    // End what was done by old shader
  
    
    float time = max(u_time, 0.0); // delay at first
    time = min(time, u_degrees);
    zeroToOne = rotate(-time) * zeroToOne; // -time to always rotate clockwise
    
    float translateTime = min(u_time, 1.0); // 1.0 = don't go further than amount declared
    translateTime = max(translateTime, 0.0); // delay at first
    zeroToOne -= vec2(u_x_spin_translate * translateTime, u_y_spin_translate * translateTime);
    
    
    zeroToOne += vec2(0.5); //return back to desired position


    vec2 zeroToTwo = zeroToOne * 2.0;
    vec2 clipSpace = zeroToTwo - 1.0;
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    // pass the texCoord to the fragment shader
    // The GPU will interpolate this value between points.
    v_texCoord = a_texCoord;
  }
  </script>
  
  <script id="2d-vertex-shader" type="x-shader/x-vertex">
  precision lowp float;
  const float PI = 3.14159;

  attribute vec2 a_position;
  attribute vec2 a_texCoord;

  uniform vec2 u_resolution;
  uniform float u_time;
  uniform float u_x_coord;
  uniform float u_y_coord;
  uniform float u_y_scale_base;
  uniform float u_x_scale_base;
  uniform float u_y_scale_varience;
  uniform float u_x_scale_varience;
  uniform float u_y_skew_varience;
  uniform float u_x_skew_varience;
  uniform float u_y_translate;
  uniform float u_x_translate;
  
  varying vec2 v_texCoord;
  
  mat2 scale(vec2 _scale) {
    return mat2(_scale.x,0.0,
                0.0,_scale.y);
  }
  
  mat2 skew(vec2 _skew) {
    return mat2(1.0, _skew.x,
                _skew.y, 1.0);
  }
  
  void main() {
    // convert the rectangle from pixels to 0.0 to 1.0
    vec2 zeroToOne = a_position / u_resolution;
    
    zeroToOne -= vec2(0.5); //move to 0,0 to shift from
    
    float time = max(u_time, 3.0 * PI/2.0);
    time = min(time, 7.0 * PI/2.0);
    float y_scale = u_y_scale_base + u_y_scale_varience * (sin(time) + 1.0);
    float x_scale = u_x_scale_base + u_x_scale_varience * (sin(time) + 1.0);
    zeroToOne = scale(vec2(x_scale, y_scale)) * zeroToOne;
    
    // float skew_time = max(u_time, 0.0);
    // skew_time = min(u_time, PI);
    float x_skew = u_x_skew_varience * (sin(time) + 1.0);
    float y_skew = u_y_skew_varience * (sin(time) + 1.0);
    zeroToOne = zeroToOne * skew(vec2(x_skew, y_skew));
    
    zeroToOne -= vec2(u_x_coord, u_y_coord); //initial positioning
    zeroToOne -= vec2(u_x_translate * (sin(time) + 1.0), u_y_translate * (sin(time) + 1.0));
    
    zeroToOne += vec2(0.5); //return back to desired position

    // convert from 0->1 to 0->2
    vec2 zeroToTwo = zeroToOne * 2.0;
    // convert from 0->2 to -1->+1 (clipspace)
    vec2 clipSpace = zeroToTwo - 1.0;
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    // pass the texCoord to the fragment shader
    // The GPU will interpolate this value between points.
    v_texCoord = a_texCoord;
  }
  </script>
  
  <!-- fragment shader -->
  <script id="2d-fragment-shader" type="x-shader/x-fragment">
    precision lowp float;
    
    uniform sampler2D u_image;

    // the texCoords passed in from the vertex shader.
    varying vec2 v_texCoord;
    
    void main() {
      vec4 color = texture2D(u_image, v_texCoord);
      // color.a = smoothstep(0.00, 0.01, color.r + color.g + color.b);
      color.a = min(0.8, color.a); //set variable here for opacity
      // color.a = step(0.01, color.r + color.g + color.b); // remove black and make it transparent
      color.b = v_texCoord.x;
      color.g = v_texCoord.y;
      gl_FragColor = color;
    }
  </script>
  <script id="2d-fragment-shader-spin" type="x-shader/x-fragment">
    precision lowp float;
    
    uniform sampler2D u_image;
    uniform float u_colour_change;
    uniform float u_spin_time;

    // the texCoords passed in from the vertex shader.
    varying vec2 v_texCoord;
    
    void main() {
      vec4 color = texture2D(u_image, v_texCoord);
      // color.a = smoothstep(0.00, 0.01, color.r + color.g + color.b);
      color.a = min(0.8, color.a);
      color.r = u_spin_time;
      // color.a = step(0.01, color.r + color.g + color.b); // remove black and make it transparent
      color.b = v_texCoord.x;
      color.g = v_texCoord.y;
      gl_FragColor = color;
    }
  </script>
  
  <script src="gl-matrix.js"></script>
  <script src="app.js"></script>
</body>
</html>

<!-- <script id="2d-vertex-shader2" type="x-shader/x-vertex">
precision mediump float;
attribute vec2 a_position;
attribute vec2 a_texCoord;

uniform vec2 u_resolution;
uniform float u_time;

varying vec2 v_texCoord;

void main() {
   // convert the rectangle from pixels to 0.0 to 1.0
   vec2 zeroToOne = a_position / u_resolution;

   // convert from 0->1 to 0->2
   vec2 zeroToTwo = zeroToOne * 2.0;

   // convert from 0->2 to -1->+1 (clipspace)
   vec2 clipSpace = zeroToTwo - 1.0 * vec2(cos(u_time),sin(u_time));
   
   // vec2 clipSpace = vec2(cos(u_time),sin(u_time));

   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

   // pass the texCoord to the fragment shader
   // The GPU will interpolate this value between points.
   v_texCoord = a_texCoord;
}
</script> -->
